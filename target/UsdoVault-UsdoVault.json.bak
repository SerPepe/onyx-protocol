{"noir_version":"1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec","name":"UsdoVault","functions":[{"name":"check_and_trigger_emergency","hash":"13285750266851029722","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"constructor","hash":"18236641791766123685","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"zec_oracle","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"usdo_token","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"xusdo_token","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"zec_token","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"deposit_and_mint","hash":"5809177404870453333","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"zec_amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"9428839017875300858":{"error_kind":"string","string":"Emergency mode active"},"12932509409780625405":{"error_kind":"string","string":"Solvency violated"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"14548928839897324974","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"public_dispatch","hash":"16063577230358026511","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1730560464670191566":{"error_kind":"string","string":"Price too low for normal redemption"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"9428839017875300858":{"error_kind":"string","string":"Emergency mode active"},"10492081608786484886":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"12932509409780625405":{"error_kind":"string","string":"Solvency violated"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14914627106065087239":{"error_kind":"string","string":"Insufficient reserves"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"redeem_usdo_for_zec","hash":"2221485377714258712","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"usdo_amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1730560464670191566":{"error_kind":"string","string":"Price too low for normal redemption"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14914627106065087239":{"error_kind":"string","string":"Insufficient reserves"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"1352816228168545023","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+y9C5xdVXU/fu7MnWFumMxNAgiBCMMjvAKEZwghyIQQQngmhIeAxRmS8DIQIIkIVh0FVJAQHuEhoMyAPFQetvXX1l9t/7bW2pf/vmtr609/+re2/am11ba/Wtv+e5KzZr73e79n333O2XdyQ875fCBnzl57rbXXXmvttdd+3Eq045mV/LvxzlvWvP3W229858imdW/fuOm//x9/rSSl1SjnU2lJ5kuLd5T0JRBdULP7v/8bjPwI9RHFbPVHr+5jhJnqR919SZ189He0P66Ts/1Rb/Lv1aOT9ZEXw7vHf/+3J7wfRvSLyK8I/7McPFvfLB2dhB+MvJ4JvTh7VNT98cavvvh7W37hN1/e9NILj8/82vSP7nnMtPfde+8/HPCDOU/98N7nre6y0UmeqlG2Po2fc0Zz1Z/gfflorvpdVv/c0cmPg/byll/qvuqGn/vJhj2X3/36HV/7y4s2T58z8hsHffiFq7708EF/9/YPWt0Vqu7fPvD0++qvPzI2OO8r/9y7fOv33v6jFT0Lv/aVn539xQ/89O9++KjVPU/V/eOrfvr1z9YfvetdWz737oVH7jXyyqNf/ce///LvvVb/0f9+9bavnmJ1zx+dbHMeP3DBaK76M6z+haNRM+/v/8TLX1+y5SvHf/un0+6/cOSed530kT+54vt37ffS3O/c9OqcV2Za3YtU3W9tWvrwpn1vXvD9vj/YcsL4AW/+xo9f+ux3/+XOdQu/992//cWDf2R1L1Z1WzxWd+Voc939TjzitFuf/MO9//rIQ/5q6AuvHLdt9o8PW/zXv3zu+A9/8jv/F+quEnVTngrTvWR0siCDrCf0c/VorvpVq3/paK763Vb/stHJ+pUou65dPpqr/gT9K0Zz1Z+Q31tHJz8ORl5Pj9W9crS57tGLaz984f733ht986X/8+C/HP35oWNnHrhk5nF/+vSfH3DL7VfP/qHVvWp0ku8Mcp8zLdox9mxKxv54PLJxaPOmG9ffuOnOJRs3rrt909INN986sunGa9evu/j2kTXr112+7vaNN264hRFW6O+lo/p7TGefRjrL1206a/2GNe+4aPPN1667vUJIK4KANTYSyPdqQn7pjTev++845+ZbGUVXCupqCurZTaiXbrhl039LZdOStWtvX7dxYxqPlcj9xMhnNiFPJJ3GXT6kS28YufGWFWsZaY8nUgsxegE+g7mstPp75Ku/zur35at/u9Wv5at/ndWflq/+Bqu/Z776N1v9/nz1b7T60/PVv8XqD+Srf73Vr+erP2j1Z+Srv9Hqz8xXf8Tqz8pXf63V3ytf/TVWf+989d9p9ffJV//O/gT+TfDRfIbh3he+ZxiS3qw8PXtQxF8jXrKGqRXCZ/S4fTZMWNv3E7zURRn7yP0Enf0EHYVrj4C4+gLiqgXENa1D27hnQFz9AXFND4hrICCuekBcIWUf0oZmdCiumQFxhdSJkLIPqV+zAuIKadshdWKvgLhC+ui9A+Lq1PHR4qw+UZYnNb1/vvrd1pbZ+FHwZPgt1sHYqJLyr+HiMqNVI1wZea+4eEf+uB9mAz1sYxqu2Rlx9YmyPH2yn6NdiL+oDrnaruJdg5/j4A/hB5KyA6D+HOL9zfl47zJe9he8zAGchj+OG2ycSJIfZ6+7dvP1F2y4nnGj6qJ4sNko9q6o2RQPSMEV0d+Msxvw4ROz/6ZG9s9Zt2nNDZeOXH/9urX/3YiNVKEJw9mj+nt/1KwEBlPQyXT5OgbDX4sKGVDFpRTKmGOp2oCfSPWCDSNrl47cunHz+nVdiDpqnFayVBArfuN+x7Ju+tZNcGePNv5tqy8MFwk8RvcAKFOSMJxmqmk6zL3yJkHXvnUJ+P0J1/6invHe7aiPOLAea4xLq3200toRP8rlG22f9EdO69k7r/UUTX+4ZB0/uALM7j0Dvb1cOoo4OQSZI8oMl7n7nkgPBwdAGxAe3+OnSt8+lfxbj5r9tq0OuoZH/NYFPH6C2oayZz0qImfEZ3zhN8RfiwrpbcXVr9g+1qM5+ejN8pE78mOyfrMoM1wHJn+jHiH8HGgDwuN7/FTp2y8n/9ajZp1jPXqzaA9+Qz36eWobyp71KKecl/jqkeGvRYX0tuLqV2wf61HOkHLIR+7Ij8n6QFFmuA5K/kY9Qvg3QxsQHt/jp0rffiv5tx416xzr0YGiPfgN9egLyXtfSnsGI69nveqLDPXv6IuaZZWh/iarf1C++jf0EXzG+u+2+gfnq3+81T8kX/33mG4eCh/ZDxwG37PsFPD1A4a/Rrzk9QOHET1uHy/LzBW81EUZL8vMFXTmCjoKV19AXNMC4torIK49AuKa0aG4+gPimh4Q10BAXPWAuOYExBVS7ztVXm8OiCukrh4YENdBAXGFlH3INs4MiKtTdXUwIK6DA+Ky2MjGe4wPKsm/faJe1rkl4jM+8RvirxEvGelVXHLB9vGc5/B89GZWqD7SQ5zGj8n6CFFmuI5M/u4BXAh/OLQB4fE9fqr07U2JwOuEM354znOEaA9+wznPjATvgGgP55ey6ivWZxliPdbXIv2J+IxP/Ib4a1Eh+6i49EfJxdp3RD56M3z6F/kxWR8pygzXUcnfqK8IfwS0AeHxPX6q9O0I0lfUbdbXI0V78Bvq68GVxrah7FmPcsp5ma8eGf5aVEhvK65+xfaxHh2Zj97ZPnJHfkzWR4kyw3V08jfqEcIfCW1AeHyPnyp9O4X0CHWO9ego0R78hno0P8Hbl9KewcjvYRszHIgb5eDfT5V/9NVDw1+LCulFxSVHZY/WvqNz0av8kHUH6SFO48dkPU+UGa5jkr9RDxH+aGgDwuN7/FTp29mkh4iTdWeeaA9+Qz18C/kzlD3rUT45R2f56pHhr0VF9HZSj1S/Knu09s3LR2+Jj9yRH5P1MaLMcB2b/I16hPDzoA0Ij+/xU6Vvl5Aeoc6xPztGtAe/oR5dQP4M2xM/g5HXU1F9kaF+k2wRh+FGWWXo5//y1WPDX4ua+y2PHh9L9NL6wdp+nOClLspQxliGdI4TdEpcJa4SV4mrxFXiKnHt2riOLnG9IXDtDvpV2lDZj6WfKO1xV8VV6lepq7ujrpbxRCmvso2l7HdVXKWuljqxO8qr1K+yH3dHXKUNlTqxO8q+9KulDZXyKnG1wlXOrco2lj661NVdFVepXyVfJa7SHqeyjSWu0ueU41DZxrKNpc8p5VX2Y6lfuy6uMtdRtrH0OaWfKHGVel/aUCn70oZKXJ2sq2U8UepEKftS9lOJqxyHSnmVNlTiaoWr03ViIPkb7wzj36tR93Md66CD9Q2uX9SrJP/2Cf5iOoOR1+N9b5nhr0XNbc5Ar+KSv5KLtX2+4KUuyrif5ws68wWdEldxXPM6FFfZxjeGvHYHvkpcbwx7LP1EiavU1dLfTyVfZT+WbSz1qxw7dlW+Sp0o5VXqV9mPJa7Shkqd2D1lX/rV0oZKeZW4WuEq51ZlG0sfXerqroqr1K+SrxJXaY9T2cYSV+lzynGobGPZxtLnlPIq+7HUr10XV5nrKNtY+pzST5S4Sr0vbaiUfWlDJa5O1tUynih1opR9KfupxFWOQ6W8ShsqcbXCVepEiavEVeIqcZW4Slwlrjc6LnVnWPzfYOT1XNoncGeo/3arf3y++rdZ/RPy1X+X3Sl2InysJP8a7pPge7c/7hMqhC9K6uM3xF8jXjLSm7hP7SSix+0zvbC2nyx4qYsy1pGTBZ2TBR2F66CAuPYIiKseENdeAXHNCYhrZkBc/QFx7RkQV0idmBUQ1/yAuGYExHV8QFx9AXEdGBBXSNseDIgrpC8MaY/TA+IK2Y+HBMQVUidCyj6kbYdsY0idmBYQV6f6iZB87Q4xUzmm7TzZh7THWkBcIdt4QofyNRgQV8g22lir5sLId4tnM881DQfiPgW+Z5j3vqVC+KJIz7MNfy1qbmeeefYpRC9Nrtb2BYKXuijjefYCQWeBoKNwHRQQ1x4BcdU7tI39AXFND4jrwIC4Qsp+MCCush+z4TokIK6QOjErIK5pAXGF9F8zAuIKKfuQuhpS9p3qv0Lqakj92jMgrpD9GFK/QtpQSP3qC4hrZoe2sVNjuZBtDBlPdGo/dmosd0JAXJ0a54SMMct44o1hQyH9REi+QurX8QFxnRQQV0jZh4wBbKy1PNDxUK+S/FswB3ZwhfAZn/gN8dei5r4MlQPD9plcrH0L8tEb9OkH5MdkfaooM1wLk797ABfCL4A2IDy+x0+Vvq3s3fFvXeA8gng4VbQHv3UBj+cleAdEe9gmVb+cIvDWRX2WIdZjfc3Zn92++mr4a1Eh+6i49EfJRemP1VX9yvL37VcXLs4bW3n89Il6GeRR9ZW/4a9Fhfq74pKL8qPW9oWCl3rUbIMXj07CcVm3+NY1xbi4v+JnMHI+1h1NsoiiZj04Db5n6JceXz0w/LWouV/y6MFpRC9Nptb2RYKXOpXFD/fdIkFnkaCzq+BCHWIfZeXxU1AvZubVi5z+yKkXym9a+xblozfDpx+QH5P16aLMcC1O/sZ4AuEXQRsQHt/jp0rf7qZ4AnFyPHG6aA9+w3jiPRRPYHtOJbyqX04TeNV4xjLEeqyvOfvT248Z/lpUyD4qLv1RclH6Y3VVv7L8fft1V8Rl+rfIQServ8T6ixx0FhSks8CTzsKCdBYKOv2iHtsTyttfvyvf9LUnw1+LCtlvxaVPSi7WvsW56FW+wT4b6SFO48dkfYYoM1xvSf5G/4/wi6ENCI/v8VOlb58i/4842f+fIdqD39D/f4L8P7aH5zNZ7RzrswyxHutrvv6M6r76avhrURH7mNRXpT9KLta+M/LRG/DpX+THZP0WUWa4zkz+Rn1F+DOgDQiP7/FTpW+/QvqKus1x8FtEe/Ab6uv/SPD2pbRnMPJ6LlJ9kaH+/+6LmmWVof4JVv/MfPXHrP5QvvpHWf0l+er/stU/K1/9ZVZ/ab76v2j1z85X//1Wf1m++m+1+ufkq/8zVn95vvpHWv1z89U/yeqvyFf/b63+efnqn2v1z89X/3NW/4J89W+1+hfmq/+w1b8oX/2lVv/ifPX/2eqvzFf/Uau/Kl/9H1r91VA/Sy7f6l+Wr3638XspfhQ8GX4bCy8B+ErKv4aLy4xWjXBl5L3i4h3543jqUqCHbUzDdWlGXH2iLE+frI7S24X4+x28KD4PhveibZ4VENfigLj6AuI6IyCutwTEdWZAXEMBcS0JiKs3IK6zAuJaGhDX2R2Ka1lAXOcExLU8IK5zA+JaERDXeQFx7RMQ1/kBcV0QENeFAXFdFBBXyLHj4oC4VgbEtSogriM6EFf8XDa649+C+Y4VBfMViwrmKy4smK9YXTDfsKRgvmF5wXzB2QXzBRdYrH0ufKwk/6pcQIa4/6IK4YsiPX8y/DXiJSO9ifnTCqLH7eN1t/MEL3VRxjZynqBznqCjcE0PiGvvgLhmBsQ1JyCu/oC4ZgXEVQ+Ia8+AuPYIiGtGh+IKqasDAXGFlP2ZAXGF1NWQ9nhgh7YxpD2eFBBXSBvqVNkfFBBXSD8RcqwN6SdCyj6kvDpVv0LGJiH7MaTsdwc/MRgQ11BAXGcFxLWkQ3EtDYjr7IC4Qsp+fofytSwgrt6AuELqxOKAuM4JiCtkP4bkK6SuDgXEFVJexwXEFVJXQ/ZjSL46VV4hdXV5QFwhdTWk/zokIK6Q8VctIK6QOYWQMXnIuULI3KPF95bHXgb1Ksm/BXP4AxXCZ3ziN8RfI14y0nPm8LF9vHf6vHz0pvv0A/Jjsj5flBkuW7vFvdMIfx60AeHxPX6q9O2PE6WuE8744b3T54v24Lcu4PH392hsG8qe9SinnOf46pHhr0WF9Lbi6ldsH68FqX6qizKOmX3lrXD1BcQ1LSCuvQLi2iMgrhkdiqs/IK7pAXENBMRVD4jrgoC4QtpQyH7cOyCumQFxHRgQV0jbDqlfIW0opF/dHWS/Z0BcIX20+UI714jxzL5EJ2tsjvUNruB5mEsKnoe5vOB5losLnkc5x+KqlfCxkvyrzppkiPHeXyF8UaRjSsNfI14y0puIKVcRPW4fx5SrBS91Ucb7i9R5idWCjsI1PSCuvQPimhkQ15yAuPoD4poVEFc9IK4LAuLqC4grpOw7VVcPDIhrj4C4QupXSJ8zLSCu3UH2e3ZoG2d0KK6Qtj0QEFdI2Z8ZEFdIXe3UGCAkrnLczoarHLd3nn6V4/bOk305bu882+7UcTukvDpVV08KiCukvEL6nJCyPyggrpA2FHLc7lQf3anxRMg2hox9Q/ZjSNnvDn5iMCCu3oC4zguIK2Se/PyAuJYGxHVcQFxnBcQ1PyCuxQFxXRgQ1+4g+6GAuJYExHV2QFwh5XVRQFwhdTWkDXWq3ndqG3cHXxiSr3LseGOMHRcHxBUylgspr+UBcZ0TENeSgLhC6kRIeXXq2HFIQFwh53y1gLhCrumEzAOEzE+E3J/DZ3Bwb1gl+bfgncjTK4TP+MRviL9GvGSkV3HJBdtncil4P3B/heojPXUHsMn6MlFmuC5P/sYzOAh/KbQB4fE9fqr07YjE2OqEM374DM5loj34rQt4PLjW2DaUPetRTjkf5qtHfJ91Tr113met7Ev1q9WtizLOT/nKW+HqC4hrWkBcewXEtUdAXDM6FFd/QFzTA+IaCIirHhDXBQFxzQyIK6Q9HhgQV0j9CimvOQFxhdSvkDYU0q+G1ImQfrVTbTukPYa0ob0D4gppj7uDfu0ZEFfIGIDPeGG8zGe8st6hjfXTfq/EyuOn4O/ZPFwhfMYnfkP8tai5zXlidiV/JRdr++WCl7oo43zf5YLO5YKOwjU9IK69A+KaGRDXnIC4+gPimhUQVz0grgsC4uoLiCuk7DtVVw8MiGuPgLhC6ldInzMtIK7dQfZ7dmgbZ3QorpC2PRAQV0jZnxkQV0hd7dQYICSuTh23Q8o+ZAwQ0keHjCc6VVfLcXvn+dUyJs+Gq4zJd55+lXHhztOvTo0LQ8qrU3X1pIC4QsorpM8JKfuDAuIKaUMhx45O9dGdOqaFbGPI2DdkP4aU/e7gJwYD4uoNiGtpQFznBcR1XEBcIdeHQspreUBc8wPiWhwQ14UBcYXUibMC4gop+5C2HdIeQ9rQ+QFxhbTH3UG/hgLiWhIQ19kBcYWU10UBcYX0hSF9dKfqfae2cXcYa0PyVcYmb4yx4+KAuELGEyHlFTImPycgriUBcYXUiZDy6tSx45CAuELmFGoBcYVctwqZZwqZ/wq5v5DPaOLe1kryb5+oF9MZjLye/grhMz7xG+KvES8Z6VVcclH7pK19V+Sjt2eF6iM9xGn8mKzfKsoM15XJ33hGE+GvgDYgPL7HT5W+vZws0NcJZ/zwGc23ivbgty7g8blpjW1D2bMe5ZTzr/vqkeGvRYX0tuLqV2Vf1r635qP3BR+5Iz9G78p89Lqtr64WuI2XtyV/ox4ivPHVRfD4Hj9V+vZ50peroJ7hr1NZ/LCOYlm3+Na1k3BdLXCh3NC+fy6RhbKP+L/ByOs5kf2K4UDcOXXlCl/bM/y1qJAtVNgPGr00H6T0yOrWRdlSeC/S9/H7gR2Ka4+AuPYMiOuCgLhCyqs/IK7pAXENBMRV79A2TutQvvYKiCukPYbsx1kBcYW0oRkBcYXsx5C6undAXCH1qy8grn0C4gqp953qc0K2cTAgroMD4jokIK6Q8goZm4TUr06NC0PqfafGcjMD4poTENfuEMt1qt6HjE3KMS0brk6N5TrVF4aM5UL6wpD9GFJenRp/vSUgrk6Nv2oBcYW07ZA2FFJeIcehkDbUqbIP6b9C5uU6NTcUUr9Cxr6dGmN26thxRUBcNnb0E24rj5+C601vrhA+4xO/If5a1NzOUOtN2L686028H75T/GFIO+rUXHlIHxYSV7nelA1XyNxcSBsK2Y8h1wNCxjqdmocJqV8h+erUdZ1OzVGE7MeQexVC+nu+exVjI757VcUhVzroYH2D6xf1Ksm/fYK/DPHSvRXCZ3ziN8Rfi5rbnCc+U/JXclF726xuXZTxPn7X/i2ko3BND4hr74C4ZgbENScgrv6AuGYFxFUPiOuCgLj6AuIKKftO1dUDA+LaIyCukPoVkq+Q/RiSr5B+NaROhOzHPQPiCin7GR2KK6SfGAiIK6TszwyIK6Sudmo8ERJXGQPsvLGjjAF2Hl9lDLDz+rGMAXaen+jUGCCkvDpVV08KiCukvDrVTxwUEFdIG+rUsaNTY99O1a+QcXTIfgwp+93BTwwGxNUbENd5AXGFzN+fHxDX0oC4jguI66yAuOZ3KF8h+zEkX4sD4gqpEyH7cSggriUBcZ0dEFdIeV0UENeFAXF1qq6W9rjz2tip+lWOQ6XeM66LA+IKGWOG7MflAXGdExDXkoC4QupESHl1qj0eEhBXyLloLSCukOtWIfMTIfMmIfczWa7D9h/iXH4B0ekVdHoddLC+wfWJeoOR13O67d87Dj5WCC/6425/3NUK4YuS+vgN8deIl4z0JvYunkH0uH0mU2v7mYKXuijjnMyZgs6Zgk5dlPE9diFw9aXwORh5PZep/s5Q/x0sT8OBvA3B9wx9u5+vLg0l77Wouf/y6NIQ0UvrF2v7EsFLXZRxHy0RdJYIOgrX9IC4zuhQvqYFxPXmgLhCtrEeENeeAXHNCIhrICCukPI6MCCufQLiuiAgLo69OkX2/QFxzerQNg4GxHVwQFw2f5mqWFXRWViQzkJBp1/UqyT/FoxFjqkQPuMTvyH+WtTc5lCxiJJL1ljkYngvqk8hx+mTAuIKOU53qo/ZOyCumQFxzQmIa3cYKzo1bg7J114BcYWMa0LGuiF1ohYQV0id6AuIK6S8QvqvTp1nhOzHkHx16tgRsh9Dyj6kbe9Oc5ZOk1enjtshbbsdY63NV4agXiX5t0/Ua8dczfDXiJeM9CouuQzBN56rnS14qYsyXjc+W9A5W9BRuPoD4poRENdeAXFNC4hr74C49giIq69D+ZoVEFc9IK7BgLgODojrkIC4QsprekBcIe3xwIC4Qup9SF8Ysh9rAXGF9DkhdWLPgLhCyn5mh/J1QUBcIXUiZGwSctwO2Y+d6r9C6ldIe+xUHx0SV0j9GgiIy2Rv63dLoGwV0Vki6Cxx0MH6BqfmffF/g5HXcy3PqwwH4sb9qRnmeGsqhC+K9JzS8NeiZnnmmVMuJ3pp/WdtP0/wUhdlZ8E7liGd8wQdheuEgLguCIhrj4C49gqI68AObeOsgLjqAXGF1ImZAXGF1IkzAuLaHXRiekBc0wLi6lTbDin7kPKqdWgb5wTEFbIfQ+r9QEBcIfX+oIC4QurEYEBcIXWijL/eGD465Fg7PyCu3cEXHhIQV0ifsyQgrpMC4gppQyHlFXJMmxYQV6fKazAgrk6dW4WUfUgbCimvkD66HDveGGNHyLnVtIC4+gLiKnMKO8+GQso+ZBv3CYirU+dDIWXfHxBXp+YLBwPiKv1ENlwh44nST+w82Xeqn7D4y9ZA8S6QSvKvrf+eBd8zrMf2Vgif8YnfEH+NeMlIb2L99yyix+3j9d/lgpc6lcXP0tFJOC7rFt+6HLgu3o1w2V4I1KNlUSMd1WdnOehgfYPrF/VYl3PuZTjdV5d5L0NO23HuZVByybqX4WJ4Z7+xM+fkIf1lp86jOzXeCxknTAuIK2QbQ+bIQrZxz4C4QsZVnZr/7tR5YUhfWOZp3hg6EXJtPqR+zejQNpb53NJP7I5+oszT7DzZDwbEVdpQNlzzA+IqbWjnyb7Tc50Dos18d998QWe+gw7Wn++gs7AgnYWedNrRnj5RbzByPj32wjlWw414sa8y5Mh6KoQvinROzvDXiJeM9CouXVQ5UWv7+YKXOpXFD+dezxd0zhd0dhVcrXSXc8JZdXeZJ51d2eb7Iu23ByOv5y5lcxnqH8s6bTiQN/w9ngz2dYGvPRv+WtSsX3ns+UKil6bP1varBC91Uca/n3GVoHOVoKNwTQuI68CAuPYIiKseENdBAXHNDIhrRkBcIeUVso0h+ZofEFdIXe0LiCukbYeU/fQObWPpv94Y/itkG0PKfq+AuELq/UkBcYW07U61x5A+ulPH2pD9OCsgrt1hHNod2hiSr5B+tVPH7fM6lK+Q8johIK7+gLhCxiadOqaV9rjz2tip4/buME8LqRNLAuLqVL2/ICCuTs117B0QVzt8tFoT4Dursq4JYP1OWONYXpDO8g5rz668Trsz27OqIJ1VnnRKPeic9uTYF2DPybaWdgJ8rBBeXD/LsK43UCF8UaTXEQ1/jXjJSG9iHXEx0eP28TrihYKXuijDfsQypHOhoFMXZbyWX+IqcZW48uHq4P1XFoJO+Br0Texnc+7X8N5/xfs1cvp1534NbB/72asELxy3xw/rSN45QKfi2s1jka4/2Ouazb2f+Jk1xx4xfdk/7jdr291n/uaWD5x5xDE8HhtuxIsyzKCzVV8bMfy1qJBNVlw6ovybtf1qwUudyuKHz8BfLehcLejUBR2Oa4rgmpe8l3OGXdhOf7zxqy/+3pZf+M2XN730wuMzvzb9o3seM+199977Dwf8YM5TP7z3EwVt8Qqrf3W++ntZ/bflqz/L6v9Mvvozrf41+eqfbfXfnq/+Eqs/nKt+ZaLvR+DroFfdybZfO4EtE+9DVn9NvvoHWf21+er/p9Vfl6t+5YdW/7pc9aP/sPrXw8dBe3nLL3VfdcPP/WTDnsvvfv2Or/3lRZunzxn5jYM+/MJVX3r4oL97+4es7g35aPdb/Rvz1d/T6t+Ur/4BVv8d8HHQq2rUZXXXA+0u//p9Vv/mfPUXWP1b8tU/1epvgPoZZDdo9W/NV3+i/bflql/5htW/HZlK/j3sz//nHv/6qa3Vn/+LH26445+PfvR3l2/5tU8vfuQrx75ldPW3H//BhVZ3Yy7a0XSrv0nQbsH3hK/bPPElWw7L6r8zM+2o2+rekb1u1eq+S9X92weefl/99UfGBud95Z97l2/93tt/tKJn4de+8rOzv/iBn/7dD7dZ3TsT8Ixt7rH6dynaf3zVT7/+2fqjd71ry+fevfDIvUZeefSr//j3X/691+o/+t+v3vbVCTt5dz7ae1v9n81Xv9fqvydf/T2s/nvz1a9Z/fflqz/N6o/Cx8HI66lb3feLunudEH31oG+ccue8Ny3YcPE77/nGpa++d+/nj/pufb8fbF78zn/76w1W9wOibovnlPiQ2S3Jpg+LXytJYfzvbHg3vxk/cT2LX/cjmPipEvyvHTZZ7/aEXj/VieC9j+pn7IvZ2AZ71JzR8Nei5rbnmTN2ET1uH88Zq4KXuigbhHcsQzpVQUfhOiQgrnpAXBcExLVHQFzTA+KaFRBXf4e2cSAgrk7Vr5kBcfUFxHVgQFwh9SukvOYExBVSv0La0LSAuELqREi/antN+0U9GzMtDuiB7xnG5a4K4TM+8Rvirwk+88QBPUQvTS7xnXU2JmzedOP6GzfdecGGkbVLR27duHn9OowmKlFjNMRSQaz4rRI1th7LuulbN8GdO9r49/mjzfUigRsjnzdBmZKE4bToE9v0ppR6KItIfOsS8D2Eq0fUM967HfXjp6BWVqz+vvnqd7tkizwZfrOwNP3Afw0XlxmtWqRlNhh5PRUX78gfe443AT1sYxquN2XE1SfK8vRJj6NdiL/fwYviE3WRbcg107Dv+zr4QvgBQdvqmoxwVpjVG6fJCG3B8Mfe0UboxDueve7azddfsOF6xo0qi+LZj+DM3XRFbneDuCL6ez/61g348HFNcH3MzviMnzrhQj7KAXTHUw6gLo3upAFUOUbWmAHxnbfIZg0/Vwl6is5lBelcJuj0iXqD9vL+T7z89SVbvnL8t3867f4LR+5510kf+ZMrvn/Xfi/N/c5Nr855ZVYsu29Qmo4HQXy3fsc0neqvKsFPO2yy3rcTerGFmXNOLOyszevfccm6TbffuO6d6/7bF2+M6GllFheONv590WhzPfW44hgWb7scneEPFQcp1VLjcjZHxwqBUomi8I7OetCePI7O5SAQpzLYnpR6aW1COaQ5IuXEKsS7y5HFTzk073iya+zuPDT7aKzv0JymsWlDM9fridI1vEqwluYrqNkN2ULmsRwDdjzlGLCrjAHdoh5rTNEMTRQ1B6Gq/X1RszwG7eVbm5Y+vGnfmxd8v+8PtpwwfsCbv/Hjlz773X+5c93C7333b3/x4B8XtK7LC3qFy+J6eyeuQWUp0jIeaWvVVrdK8PvPnKy3X/IeW97cpDyxvMtH1t+4dmTTumW33LZ53eZ1ay/asGndxiW3rF32znW3bMocEq8Ybfz7vNHmeuqZFk02+EjCj42MHzMegz8q+d4LdBCGBWTwByZCiRcD7kpODSilM376qb6Vx48pxTHE+2Dk9Xi7bMNfI17yuuxjiB63L5/LRnVmqSBW/MbmjGVT4bKPhTIlCXbZ2KZjU+qx5vK3LgF/DOE6RtRjl63qIw6sxxrDVoRu5khBm61oPljRexan0z0yapYDW1JF0DOrO5Zg48es7jhq02Dk9Vzha3WGv0a85LW644gety+f1aGmIJXLCavBICw+lwNnCM9/c+9VRT1+OFA4jsriR11snEHKs3x71fDXokJaNNGr6lAEts/kb+07Ph+9mRWqj/QQp/Fjsj5RlBmuk5O/0foR/nhoA8Lje/xU6duyxDvUCWf88GG2E0V78Btu2juTAihszwHUtqyHVbC+61DMcQXpHOdJpx3tsX4yn/F2CBZXkmyPcbRZjTbHeLb5mCidzgEF6Rwg6Jgd4BLdPCqb7SjbH8qOo7JDoYzXsw4DPk3nrWyuaLOVHe7AeYTAGfddbdZknfi/RQCnRhqOak4DmlgX/+4h2Pixw4BVgl0PerV2ZmMbsL9Z1srOrAx9HMtF+RcrQ5/Fsj7FgfNUgXP75G9WIxzLK37M158O37NMNn3HMsNfI17yjmWnEz1uH49lZ+ajd1mF6iM9xGn8mKyHRJnhOjf5G8cyhD8T2oDw+B4/Vfp2F41lQwDLY9mQaA9+w7FsE9kFyr6S8q/h5W/sB1E21n9GB219P+DnfTMb24J23y3qWiKEbf9fD52s9wEaU7A+962yo7ztXyTa6JJzQX3ey9deDX8tKuQfKi77wfaxvQ7lozfLR7+RH5P1uaLMcK1I/kb9QvghaAPC43v8VOnbNrJXtG2213NFe/Ab2uuDZK8o+6L66vJ5OOtEe/0o2evpUNYt6tqh5SrBfxPs9RmyV9RP7tt2tZ/H/eMC0sE4lA/+KF3A9pv8TDZDUHYu1UNdRTjM3qCurxC0FX7D0Uo3PjVTty1NN4aSdx77vgS68aqHbgxE6f05EDX3AfrpNP+C8G+LdLt6U+CHUtr1WchejS5uxGn10+IIHvcM/pcA592LNZ/YLoyjOfmv9EH5RiXTFVFr2kPwjfPqVr83cusi+91fEzJV47HV7xe88HjMej8YeT1n+fgHxF+LCo2PFV9Z83i8Ih+9JS49QZws65WizHDZ7jLUe4RfAW1AeHyPnyp9+wqNxysBlsfjlaI9+A3H4y/TeIyyLzpOKFtr5XP/mHzuEJQpn2uXcFQJ/jXwuX9GPncI6nPftqv9PGdeEZAO6iqPx6sIF7ff5GeyQV1dRfUugTKEw/EY9fkSQVvh9x2Pvz1Tty1NN4wW29KjoBt/Q7qB9c8l2QxB2Qoqw77m8bjVOPR2gje+eyN3nFMl+O87xmMVu6De8Hhs8D90jMfKz7jGY6WLyjcqmfKu39MELpQzj8dKptj+06j9Bv+vnuOx1Vf5uaOpDPNzPE/B/BzPFXBNgeN7zM8dS2WYnxuislOhDHWE83P7OtqDeV/OF2Pel9dUDoWy46nsMCg7kcow73sylWHe9xQqOwLKToW2Wt6XN4H0J98L7k+QW9nS8uoMh/9Gkd94wEfKkM4xAekgLttK6VpxzkuHV4yRznxBp+Aaofd+EsNfi5rtOk/cq9Yk1dpUtpVtXnVCqSBW/FaJGluPZa6V7fgJsZ9ErWbOFzhtpMA2nZhSD2URiW9dAv54wnW8qGe8dzvqIw61csntt+9p+0kMR5Xg5yZqEY9WH6TRWtFCefCIabyn7QxjHgz+KODhrsUaZzWlXfNTcC6eNSmPY2ZpnJHAqdp1IrWLeTieeDD446Fdo7RXR632Rynf0La4Lv+tdOZIgj+5RXu4nwx+gaOfjhM8oE2yTJkHhjkxhYdFggfh3ZZuuPXOxLtF9PChCvZOLHned3OcwJP2GP5YC00jOe5lT6W+sQZY3bjl9mMsE0dd16/btC6l7V2CN0WzK9KPzxiacy3Ueww1/KHGULVmr8ZQXsfCumr9D/sX/25FJ+5T+/GspE9Xb9pwe1qX+g6uFcFWFKUPsqhyEdXhJU0s21lqcFo+ek41UFPTbKEUb/xCqSBW/OaSfKveDnE+SW1GOE3gtFAK23R6Sr1WTq5LwC8iXItEPeO921EfcWA91hi2kLRQikMOg38rDE3vWazbaX9fD++89bYNG1tm+lrVztrYks2q2LUalRmE1WAQFp8ZwBnCpw2L9lww2lyPH8PjM2Tm7NX+vL1adMhUvaqGsoLbO/asUH2k12nblW5O1Df0dqXrKdVkun8XTHA2JO9quw+PQCoMUeNcPUr3mHw0J37nLYU4UeStgcc7yny3FHJqMM+Wwt+klGWIrWCuPkbPx6Mo6vMQ4Tq3Ba5LCBfW5+XGFS1wXUq41DICh7tYz7VcZf6Al4IGI69nuq+/M/w14iWvv1PLFtg+9ner8tHrr1B9pIc4jR+TddoyW/zf6uRv9HcIvwragPD4Hj9V+vYw+TtcumN/p5b18Bv6u4+QTaLs89okL4Fj/7Xanvk4JY/U9jmse0Pyzts0fvbQyXofJX+N+sl92672s/+cH5AOjhm8vKx0Adtv8jPZqOVhq4e6yjandH21oK3wG45WuvHSLN22NN0wWlWCHwHd+JRjLF9JskG5uY60cAyk/BnC30DwxndvCnzasvnPiQRoheqrbS/xYzE2J6w/Czh5eVn5TTXbcOmi8rNKppcQLjXbxPZwAlTJFO3T8LFMf0XI1Gf7OcZqvByLyVteQsYFjCEqw8Qzb4vBWI3jRozV2A/j8jLqyG9SHGzt+TItueac28glV7YplCEuU2NZFE32pzraXRf1j3LQmVuQzlxBp6CsKgVzfBO3XrpSoi4dtnL1r+HiMqMV6ii/4t3VDyHnZApXnyjL0yfzHe1Stqx4UXzyopJtAVmd5LpjG/86xX54mL9C7cx5C+4CX30x/DXiJa++qJtU1W2zaouM1a2LsovhHcuQzmxBR+GaFhDXSQFxTQ+Ia1ZAXPWAuEK2MWQ/hmzjXh3axj0D4rogIK45AXHtERDXgQFx9QfEFVInQtpjSBsKqRMh5TUQENeMgLhCyr4WEFdI2fcFxBVSXiF94cyAuELKq1N9YUh5hfQ5u0PMFFInQo7bIWX/5oC4Qup9SNkfFBBXSNmHbGNIPxEyBggpr8GAuA4hXL7zeoM/VMCrvJHlAjFPaHUtB4JHXjLkJLpccjgUcBr+Ar+oYuI5heAsHd4VNYt4/xRcEf19Cn3rBnz44BWwbdy6eGKF8HEbIsI/1VsXs+5gvQjesQzpqFtPFK5pAXHtGRDXBQFxzQmIa4+AuA4MiKs/IK6QOjE9IK56QFwhdSKkvAYC4gopr1pAXCHldVJAXCF1dVZAXLtDP/YFxBVSXiHHoZkBcYWUV6eOQyHlFdLfh9SvkD4npD2G1ImQMVNI2b85IK6Qeh9S9gcFxBVS9iHbGNJPdGr8NRgQ1yHJuzoodhTRUXPYRQ46WH+RBy41Hzb4IQHvSsmorfoFb07rcsl7CHAa/gIpGRPPCQTHKRnsyjNTcEX09wn0LS0lw7uAfivZGmBizLk7S+7i4911mGo6mfjPmhnE+rMddPYvSGd/Qadf1LN2F5Sj90kLw1+LmtucJ5WldjcquRTc7TZx0uI0QQ9xGj98NlO5MLMX3NGsLnxS9oVmzxfFfi2xjXrU7N74pIWvG415/NO9GtuWd3cl4lXu2Udf89JBfbOd+WrnPNu5q98VHbWbmXFhv+MO+lMIHnd2K5zzoBzhv5v0Vxzm3pfs/FYXhOEJhb/bqzWv8wWvfNpw6aGT9b6X4FRytn5XenAalc0WdBVO9p1Z+25/wYMLF/bXoQRvfdGbAm/4uO/+BfqOT0JY/TT9OS2FB9Qf5CFNf36SQ39+uldrXrHuoUTb4OeC/vwX6Q/Wd+nPfCpD/TEZqbGXd9BnHXuxvmuMP5bKFO+ucc61e1zJSNG5vCCdywWddo8PlxOdUwLSUaeC1XTkrfCOZUaHvzEdrL/IQWduQTpzBR0VaxwOOAqewu8uOLWZOFkwhB8FT3yCCGOiLHqAtGqEKyPvFRfvrmnwENDjH2BQuIYy4ir4wxITfeL6IQvE3+/gRfHpc8E8fnO1eXZAXMcTLmV/bxW4DN71YwUI7zqJX/AS8i5X36nT+gFSBZcTnB3274qaVXwoBVdEf19O39JSBcqNzk/h0+i2cqNYf6rdtaKzoCCdBZ50Fhaks9CTzhkF6ZzhSeeNJrepas/ygnSWd1h7Sr1upFPqwRvDTtvRnjZeM+edNjb8u9jvJ06kjXeFC8k2JxfDchgcP0UuJNuQ4FW/R8V2kXX1EOsbnKKzsCCdhZ503mjtOaEgnRM86UyV3BYXpLO4w9ozVXpwYUE6F3rSKf1B57TH9dvZsV8f31vTxHEJ61qKkZcrb9l3st4naKzAVE4vtTFrWh7ru9LynC7HNvCy0+ECZ4XKkL/DHfxh/cNT6iE/8VNw2X7iYp5T8tWfSAuqX9NAntJ+J8fK1b+Gi8uMVo1wZW27i3fkj/sJL7HiJX2F68SMuPpEWZ4+OcrRLsTf7+BF8Ym6mEanF75xSnSRgy+ENxtD3bS6BecdXa7+wrmF4S+QEjXxzCM43j2FIj4lBVdEf8+jb61Sotj97K6OoDa0MgOsf0QKLvwRFjWMVAn+oeQg5PafjUyGAtdqYkFTOSmvyyl6F5jLXcaPyVrdf2d11YrlOfCOZUjnFEFH4eoPiGtGQFx7BcQ1LSCuvQPi2iMgrr4O5WtWQFz1gLgGA+I6OCCuQwLiCimv6QFxhbTHAwPiCqn3IX1hyH6sBcQVsh9D+q+Q8rogIK6ZAXGFlFdIGwoZT4SU15yAuEq/uvP8akjZvzkgrpB6H1L2BwXEFVL2IdsY0k8MBMTVqfHqWwLisnjVcg84R+fcQ9a0GdY3uIKpzK6CKaWJtJtKbyFPnF7HdlZS/jVcXMYXA+XMgzgvBnL1A6bKsI1puBZlxBXq3vhTHO1C/P0OXhSfnAot0ubjCJdaPlA5oqx9NxVp1eMEL4HTqiaeEwnOftqqK2oW6ykpuCL6m02yVVoV1cB1qIMPlWU9bIH1XYc65hek43t4ZP+CdPb3pNOOn7RQdGYXpDPbk86ygnSWCTpq1Q0Pq/HKW/yOq7lv36eRp2OhTK0eHZq8Vwn+qX0m6127T6MMUD52z98A/R2/H0M844qn2WCIKw0RXxTpIdbw14iXvEPsYUSP22d9ne0HTtkSUSqIFb9VomaPVgHO8Bsfwd2X6tliVneU/pjEjO5cKFOSMJymIdimuSn1UBaR+NYl4A8jXIeJesZ7t6M+4sB6rDEV+p72s8GGo0rwmxKriifPH6SjoYoWysNkynpix1MZhnkw+HcBD3ct1jirKe1ia55Lf6NuLR3V9LeAl/nZfTT9SNDn9uHo3ZvCL7YH4UdBBnZEt5tgmB/1DWWAddP+Rlj8kRn+W+nikQR/RIu2c/8b/Icc/b+/4AEvuGX5Mw8M86YUHj4ieBBec+mGW+9MvGZETxXelZfjXuKe2F/gSXtMGrHGmvaydNg6mI79rTQgbrktQU6E0uvXbVqX0nYeEWan0OyK9NMfad7ipy8qNFZ6j82GvxZpzRuMvJ4Ke0+jx+3jZfnDBC91UZZmpa3oxH1qy91Jn67etOH2tC71HbSVs+D6EdWtiG/xg1cl20CNUy6e8qiZIX5zTXkMTtGZX5DOfE86+xeks78nnbkF6cz1pDO7IJ3Zgg7jSptCXJu8Vwn+FXDs/IudxwEfjDN+7KCpwavMj9okavCt7vdgWWIWie/dULRRljwQLsrIq+sQC9JXd6ScnpHXS6aY1+MEr208iOQ95Oysg0jZpoOci0WpIFb8VokaW49lPLIcTnArRhv/zjMdVEekFgmcavv7mSn1WLP5W5eAP51wnS7qGe+u3CbiULlWw6HqxX+/S9RxWYCPBscPBzFnBsQ1JHAVvA1kH1/LNPw14iWvZaqbG4bgG7d9heClLsp4zWCFoLNC0FG4jg+I68RAuOKHjwuWuEpcJa4S166GS63TDlE9HD9t9qFmBzxDzbrnAesbnKKzrCCdZYJO0b0Kio7iWd2CxHIbiprbM+Sgg/WHqD3HQhkuhu3xJk0TZ7JY125frBL8++E8y7Q3pbcR5by9XaPNPNu+ziqUZYhrBuLZ9AN0iyPGOD2jk3jT7AdjuI3Ju4oljqIy7Gu+tS2tD/amPjgRylQfGD9Vgr8J+mBf6gOsz7euKbtR9FhHelPgTyT+DH5OwhMuIyj+FqXQQ3mgnN+dQm8Q6N0N+rC9naOT9Y12Qb3bR+ndEACw3vnG3b56yuelUE85Y3OswIV6wBkbq98b6T4wfHw77jzR5756zv1q8Md59utQ8q0d/Yqy4n5VmTU1Drn0APvLZFKPmvs8LROJuLCvffr1WIGf+/U0R7+qDRXIJ/erwS/27FfcB7kdD5QV7VeUlU+/Ijz365CAx341mdSj5nHyMMKlfLQrw6r6FfuAfbTBL3f0q8pyu/ywwZ/XAX4YZeXTr2olwLdf2Q8PQdmpVObaFzlVPvpy0ecc87NfSONPya3g4h6vRZ+ewsbeon5EdSv0be8UXIYn/oZpVRa5NTft0nMWucH/jBC5MlPkR7koa0/B4+HeiwJ8PPzYfPScx8OVS816PDzrsNgGVY0fWy2oCLa4fkS4KuIblilVxfVBU1W1HRJH6LfT1kVUIZ/7mVXkb/AWgaZFF4avSvAbHKOQKwqOH/bWKwU8Rsa8jRnbsJLKsN6iFDppl9Xx6Gjw7/QcHY12O0ZHlBGPjqugrFvAs7wvEfCrAGYoea8TvDJplPFKotPKdbD+Kz1Vs28Vjc+P0tvbalbG+jUEZSuoTM3mlC7gfdnxU4WyopkSbA/rgsuW4odl49IdlE09aq0naJcriM6QoOOrC1YXs2F9gBvpDEZezxFGR60+G24cXjP02RrkyR41VNu3GvGSd6juJnrcPh6qq4KXuihbCu9YhnSqgo7CVQ+I64KAuGYGxNUXENeBAXH1B8QVUl5zAuIKqV/TA+KaFhBXSJ3YIyCuSkBcMwLiCqkTewXEFVIn9gyIK6RfDWnbIXW1U/1qSJ0I6b9C2lBInQgpr4GAuELKa1ZAXCF1NSRf5bi98+QVMl4N6aNDxgAnBcQV0n91qk6E9BOdOg6FnMOEbOM+AXGVfvWN4b9C9uOSgLhCyqtTfU6nxoW1gLhC2mPIsTZkP3ZqvHpeh/IV0q8eFBBXSD/RqT46JF8hZd+pfiJkTL47zGtDjtt7dyhfIee1IfsxpD2GnMOEzPuGxBVSJ9iGKsnfCDMP3o+GcoS3H4oquFa8ltdiDQfi7smJu0L4oqiRz4jw9wt6xlctpWwwcj8/XvOFgdfuv+KVCtU3Xvgb70/oFfBqTdtkhbqSQVbXqj0cRtvKqlDWQ2U9UGY8xP8+t7iRv96c/PnID/HXBTyfSvPti5lRsx2ZHtm+GNyHNj9qpOP6wVGkUxf1z3TQmVuQzlxBh3Gl/YDctcl7leDvSPyCui9kSPA3V/Bn8K7TJ8iPkg2fbBoCXJWUf40Of2O5DQHMfKJzbkA6uNfqNKKzIiAddYpd7bsrSgf3VfFpxlUB6eAerdlE55KAdHBf4FFEZ3VAOqsBBq/Njf++FMoOBRzGx2WCD/PFV8D3DL646tMOxF8jXjLSm9jfdQXR4/bx/q4rBS91UfYOeMcypHOloKNwHREQl/XtQNTc1/xjppcKOpc66CzwpLOwIJ2Fgk6/qFfURpRsjM4VAemgzSwkOlcGpIN6sB/RuSognasAZh7ROV3wEMcDr+87+T3+72oo66a68WMn8asE/1uHTNb7+QSn6SD6CuQR62M8dploB9P7JZqzXAN1MvijhjlnRLhaye5zJLvLoMxHdgb/SZDd50l22C627WEou4LKRqDsSipbA2WIA8siaAN+Y53D+gbXL+rxeLUWvmforx4f20D8tai5zXnGq7VED9sePzx3W5ePXtXoXSfoqX6YEWmZIn3DZTam/Ow1VIa+cQ2VoT8boTK076PhHXGmten80R3/qrGL9Rv5G6KyISg7l8owDufzEBg781kcbDPHt9bmHsITPzZPrRLsX8OPc/9F8q78DfvxywRuK7talMX4bz2gsS3oU1COWBY/3eKbawy9JgVXNWqe88UP+0OD/zfy7cOAN4MtXW9yGYGP7Idy+oXrff1Qmk9EvpSP8slHbTvyB7M+tebf/zKr73b5tLMFfEGfJvNRRlvlo9ZQWQ+UGQ8qH5VzTLnWR36Ivy7K3gnvWfqiLsr4rtW8uNgXFsW1Iicuy7mNQP1hwqXOteF4wWPDkIOva1rguoRwYX32YcMtcPHNVNeINrrmLgV9nHc8NJy816Jmv50nHhometw+nr+rvq+LsiF4xzKkMyLoKFwrAuK6JiCuduQzVXxzBvGscrDnOng+Q/Cs8qZnUHswBmy4eWo/zQ/Ol3A+vHp0x79Vgn8C5kv77tfYfqQ9FDWWIc+ccxkCuipWceVcXHSWF6SzXNBpdx6ccy7XBKSDdrSc6AwHpDMMMJxzGQlIB+2aY/VzBQ+xzh5DdrAGyrpF3TuT9yrBLwQ7mO+wA+QR62POReWOmN7JCY2C8ZbMuWA86JLdApIdzr2UT+M5hsEfALI7jWSHtIeixjKU0zVUpvIqA1GzrDgHpuJw/ObK87HcsJ7Jt2D87h1jGP5aVEg/JmKMdUQP2x4/PD+5Lh+9iZzLTYKe6gfMuag8C+LinMsQwPCYir6R5xrDUMb5mBEo45zLuS3a5Iqref0Tx+v4b8z5c57DYPcAO1uZ2JlaX718tLEMdfxSoLuabHUY4DiXMQz4XTk7lcswuJBjk8rNcow2EjXzPOLgGeuPUNmwoMNjOvvXa/bT/KB/xXiAYzSD/+eDJ+uNUJ+pOZLqT47RhoGuT38u8KSzvCCd5YJOu2MajtFGAtJB/eQYbU1AOjhecoy2NiAdHIc4RrtC8BDr7DvJDtZBWbeoyzGawT9+8GS9Ox12gDxifYzRrhHtYHrvpRgt55goYzTD1Up2oyS7a6CMZRc/aXngO0F2d2fwITgmj1AZymMNld0EZYgDyyJoA35jncP6Btcv6pl8rb/Ww/d2xGiGvxY1tzlPjLae6GHb44djtJvz0ZuI0W4R9FQ/YIyGMkX6hotjtGGA4XWxESi7icrQn11HZWjfHKMNR+42cYymdJ9x4R5fFWdVCf6ZxL5iW3uK4jS1xhPDHTK7EW4E6LBeo2yy9jviiyL3Okstau6nPHqtctvYPs5vrhW8qL6/A96xDOm45n6I68qAuHguizrGcVjWNcIFnnQWFqSzUNBpdw6L47B2xUe8P6ld8RHHYesC0sExkeOwYcFD7GN+hWKJ66BMxeYcSxj8/gdP1vs1iiVGgDaP+7x3guE5DjP4L1IclnOclXEYxxPDUIay+5LHXG4YaLHsDP4/Bifr/bZDdmzbvrHWWirD8RpxYFkEbcBvrHNY3+D6RT0er3LGKd5xmOGvRc1tzjNe3Uz0sO3xw3HYLfnoTcRhGwQ91Q8Yh6nYC3FxHIZ+doTK0DeupzL0ZxyjoX1zHGY00trkisNGUnD5xmEG/03yGznjJuk3DFcZr/nHa7yvo0iMVTTvX8Zrjf8aHf5Wxmth6OSJ1/4rULz28cHJel3JPLOd8doeCY2dGa/VZje2ZQTKssRr7x+crNdPskPabNsoJ47XMI7ieA1lhTiwLIr88mZYf3fLm43At10xb6byUso3ckyG/ozzZq54bThyt8knb+ab42KaaXHdFaON5QZ/xOxJnHMpb6b2Y8dwr5b5tTdMfs11foHjNXVO4goHnQWedBYWpLNQ0Gn3uTyO19p1Lo/jtXbFhTtrnXNY8BD7mHPIv6l1zmGgyTGHwR8yOFlvhSNe81nnHBHtYHoXUbzWznXOYShD2a0MFK/1DE7WW+2QHds2jo18xq9c59zxlOuc6fEa+tkRKkPfGGqd88oWbeJ4Dfm7MgWXbxxm8O8gv4H2VdRvGC61v431/8p8dL3jNcNfI17y6r/qO3V2QJ33sLpqjsf5tRFBZ0TQUbiuCoirjNcm6fC3TozX2nWPws46OzAseIjjg/sp5lgDZT4xh8G/eNBkvS2OHBHyiPUxXhsW7WB6j5Df3RlnB7alzOV9zw4Y/H0guydIdkibbXsYylx3MlxFZSgrxIFlUeQ3J8X6u9vZgWH4tiueHUA/y2cH0Dfy2QH0Z5w7GYEyn/saXGcHlO6rHBeeI+Acl+uMbM6YacBXBzlmKnpGVsVMaryOf+9qbvKe/Azw8nWbVm6+dv2Na85fd+fGJbesXTly+6YbR9YvWbv29nUbNyLTSAgvBMVyfBjG3leI74jjqhaNYWXAzuLAbLgFLj6gjfWHCddIC1x8QBvrY138uydq5tMOuHR54EFDS+NrNfGFhriGcK114Irf74wacWH9tIRLGq6fJVzqUhn+uydq5pPl5cKT5kCRr/cQX8phGq71LXDdSriw/nrCdXMLXO8lXGoSzn/3RM18srxceOL/bmnB1/uIr7TNN/F/G1rgupFwqc07huu2FrhuIFxYH+vi3z1RM58sLxee+L/bW/C1kfi6DcpupzKsxz/MnXWShvWnapK2iOjcHpDO7QCzH9SL/94EZcOAo198Mxo2+G+G7+1ImBj+GvGSkd7E4L+Z6HH7OGFyl+ClLso4EXaXoHOXoKNwXRUQ1yZqT9ok7Hs0CbsSynwmYQZ/O0zC/oEmYSij26mNKo65UtCrULt6BTziqxL8jxOe4ouKRpOLipSNXJXCC4+nrkRHX9RsX+2wEcNfi5r1J4+NbCJ63D62kc2Cl7ooG4H3NFvcLOgoXGsC4rqS2pNmI937N9LMayNXg430Jjg7yUb2THgqYiMYQ/nYSM6FJ28b4YWnojaiYlmXjWwSvNRFGW+sV7a4SdBRuG4KiMvXRvYPZCNng428uY02YvL2tRGDPySAjWDc7GMjRZJhiM/4wW+IP5SNqMtSXTZyk+ClLspwzoRlSMe1OI64bgmIy9dGTghkI8eCjZzcgTZyWkYbUby3Y+6l8lcnwHuajJTu1kX9q6jsCkGnlY4s3V/zk3YZlc3fmy5UAh05x6EjnbCwurggncWCzlQvrLZrwXMx0bkuIB0cV3hh9aaAdNBX+l7KdjXZwXooU3Zg+aIqwX/+wMl61zjsIC1niQurV4p2ML01CY2CG4/kwqrhaiW7dYHGmWdBdjdk8CEY07OPR3lcR2U4JnPeV+VX8RvrHNY3uH5Rz+Rr/YV5y3YsrBr+WtTc5jyxlu/BT2vf7fnoTSysqrmE6gdcWEWZIn3D5VpY5c1K6BtvoTL0ZzdTGdq3z0Y4bJPPRjjXBps+wXs74njDX4uabTSPbrWKFzmOv07wovpmFN6xDOmow9IK1xUBcdkaQ7nJrPlbJ8RCvMlsd4mFns4QC8UPj+cGPwTj+cenIBZ6vgNioRcCxUKHguxeLmMh17PLxEK35aM3EQupNewssZBa034jxELdgj+EQ9tT+aRIfKs46DGNLlH3/VEj31h2IdHImgO6UPDbxrxut6997Sp5XV5DL5KL9Yl5dtahj3ZsYLwQvgXaRNvt6gfXhd851/K6jJ5rbxfSi/1pb9Tch2l70NTeLeyvNJvPu5/yuha4XPspeR3wpha4eD9l2sZlLPtBEr/Efvh/7d8IY3sBvwUw30ze2aZQDtv3khCcuvyk4IUe3rZn+GvES17bU/2gDhzGurlH5NYR7KMReF8D7+rSLB+dRZ58dDZrn6pN5THcDx1wIwJO0Yr/xn3PhoNj8R/B+tKrixvbiHSH4R3L4kfF/q7DGa4fLlxQkM4CTzoLC9JZKOj0i3qVlH+NDn9jOko2RqddP67+Rv/B4LTLvacdMPmdbc01XvCh999882S96fQDlcNAO+1Qp+8BNIOfldCYiov10mS3N8luGMp8ZGfwL4Hs9nXIjm17BMr4x09RHnw4DccGxIFlEbTBdQAN6+9uB9BG4NuueABNjXXKN/IBNPRna6jM9YPBK1q0yXUAzerGh6uSVBocrjp/3Z2Xj6y/ce3Iphs33HLJuts2r9u4qQqYmTq2Ioq0Jx5O3hEPPxX6u4vKzqVyPOWgHp+rBtDi2hH5Gv5QVw2MED1uH8/61whe1FUVH4B3LEM6awQdheuagLiGk/fyKs/mb1mu8hwOSGcYYDjSGwlIB22TI701AemgvvlGeudTtLICynyiFYM/F6KViyhawVEDeUTcGOmtEO2oEvxqivRyZt1kpOe78/IyD9m5VoEMfh7I7q0kO6TNto1yGqYyde2PmrHzz+eqbKBanVcRwRTsWvCO9KZi1wLGDhzp5YwsJyI9FVmqfsBIT/1kJOJyXeXJVw0MQ5nrap8rqAzt2yfSwzb5RHqmW6cLOlZ2GZQNUdnVUXObY7u71WF3K5P3KtH+IPkgtIUMfX5GP9ExHIg7Z5b/DF97SVvhQL7UikPVg5eTvvXFfbqvW/tJ9vnGC3/rAvxpPuksAV/QtyzqNxqjk/XRp8VPFcquoLIeKDMe4mzic4sb+cvpixb5yE/ZK8IvHZ2Ey9IXauUYbSQLrplRo16h7Zj9oX2vSt595kE5bdB7HmT4Q82DlE90zYOUzOqi7A54Z9/SLb51OXCdHhCX+WbVzzwPOl3QOd1BZ4HgWdFZWJDOQkGnX9SrpPxrdPgb01GymeqM98qAdFAPeB60KiCdVQDD86AhwUM8/r9IsTyuQnVT3fjhWN7gf3/OZL1POmIK5BHr4zzoXNEOpvfaFM6DhqAMZfcZkh3GVT6yM/jXQXa/4JAd2zaOSTyOoDxWUlnaTiIsiyK/3TpYP8tuHYzB2zEPMvyhduuonJEa4619w/noTcyDRgQ91Q84D0r76UzDxfMg9LM8D0LfyLvP0Z9xzIX27fNz7dgmngcp/spYyD8W4utni8QvlwbE5YpRyliokU4ZC+WjkycW+ptAsdBKGM//bgpioR90QCz0w0Cx0Ekgux+R7JA227bKmak4iWMhlBXP67PmhLH+7pYTVuNVwVhvIhYaFvSy5IRVXOSKhYaoTOX6lT/jnLArFhqK3G1yxUJYF//uEbBnRpPtRdhpYGfHz0mndUnUWHYmlK2msiEoc9kn4kD5pp1Gv5baYPAzE77jXONnFmucXZF7TUrlPoeSb31GF8oy6O+vx3w9sHiSDupL/PSMNvKM458rpjL4SwQ86hzHhpdAGcdzQwIXxhemj0pexmM75IU8+MhLrU35ymsoeVfyuoxwqfh3CL655GU8tkNeQwDgIy+Ezyovk4GS19WEq9Uc53zi1XD3RtonGL4qwR8LPoFvy3H5+DMFbvSNFcKB7ThUtKOfyrBujHd87x3vU5Xn4VgTfwaQdQHxVgl+EYwbF5JshqPJx2d9a0TADwPMELXH5yepEde5DtprBPyIg/YwlPHelRH6O+2nGLfTGp0sM9kU9AM9yg9gvor9wDCUufY/uWQ1DDBDybtaCx+hMt+c0zVU5ptzwhueWD9V/mkIvrHtDgle1VxHzRNcuue6CULpnsqxKvtnv4H2z34DdZT9xjCUsd+w/sy6Q/3qpC/auUOd9bsaaf1O23l+G/i2a1J8W09GnCMwHt0NNho/ar29oC+oKl8wDADsC0agrFvAZ/WbbLfYN7zWoNbNUaYcE5iMegU84uMTTus9Y4Jh4t03B+6a95k9xHqzNeGDcwLxO+ZSNpLuqVvr1E2DfGvdI6DP76Q5Xgi/sYrKhqGMT7ZYWRS59UztnDc4117YgvvBvXMphj/UTeojRA/bHj+cS8npNydyKepEy7Cgh7kUlCnSN1w2Fky1X0M5+fg1tdbks7cPfQT7AbUXlX2Eooc+AmPxrWT7ykcOCbwqZsH89d9QLhXti+0fbZztfxjKOG5AGXLcsAZ4UTGP4eWfVvso+LBXSDZKl11xrNpbqn4SW50aW+eB6yoHbXWK3fUTt+pn45mXKEq3SWWLJpt2zDcwLmBbVP2E8D6yUv2kbmdZR2W+truGynB8H6Yy1O2R5F3pZ6sb39h21YlyjAd2tVzBL4Lt/k6ZK2iizXxavTJX0Gy77c4V/E6bcgWfKXMFmXMFX90FcgXfB9/2tUC5gq+XuYKJsp2VK/jbDskV7JmcjWuVK/iHQLmCATiL909lrsD1lLkColfmCnZOrsB8hMtHDgm8rXIFL+6iuYJ9wIcdSbIpcwXpNlnmCrLZbohcAetnqFzBP9DYreZJaq4wTGVXCr6VP+B4ei3wwvMbxFsl+BPBdpeRbJT9uHIFreyHb45S9uPC5dpjpG4qus5BG/nim9HZltXZ9qnOFaB9su26fGb8+MhK9ZO6mZZvwFXjkDrTz7c3jUAZ+wrUbbQx1k/fvU3qXg3ca3RZm3MFfJu6mrMo+2e/oeJt121qStfZb1h/Yq4A4TlXYPCrk76w+DPnTagyV8A39+N9Ekq/eW5l8DeCb7s8xbf1ZMR5ZYJnZ+YK0N7ZF7h8cPxk9Ztst9g3fJeL781qbGe9kY4heK+hwa+FPuBcAfojjjOGoYzjjBFB13XPUaw3H/LMFbwjJebImiu4H/T5luQ9pN9YQ2XoBzhXoMYcpWcqV4BjKNczP1DwBkPvXAHfLp/zRsjMt8sX9JsTuYL1gl7ajc5KpuqG8U7MFbSSK8/dsY1sz+gj2A8MQxn7jxEHPTW/Qx/h8pHqhnZ1Lw7GLOc7cgVs/2jjw1SG+j5CZShDjhtuAl5UzINjNsI/DD7sEyQbpcuuOFbdtI+35PN83fUrvAqXK1dwi4C/2UFb/XoN8xJF6TapbNFk0475BsYFbIuqn9QvW7hkpfqpTvAom6y2exOVjUAZ2zXqtum80s9QuYJ30Ng9DHDtuF05bexWdy4iXo59XwPb/XWSjfLPI/Ata9zJcyY1X3fhGnbQdumvoo18YV2mzXxaPWW7Jpt22G7I+YGSleqnetRs12yDvjc9s3363vSM4y7r53DU3A7fcXcY8PJt62sE3mH4xvJ05VmV7o2I9in7d+XW2G+4ctrq1y/ZzjBXgPCcKzD4P6BcQc5f2JG5Av5VOcxnKP3muZXBfwd82x+n+LaejDj/zDNXYP3Yjpga7Z19gcsHx09Wv8l2i30zQrhGBC6UKecKTEa9kc5ZGj5em/qmI1eA/ojzmr43z49Qmfr1i+16c+COd16Lid8xV/DdlPUz1D30Oax7Bt8Lv/T49xRvhPAbnLdUOSPXmOP6NVu1LqD02fxAwbm0d66Af40pZ27C+WtMar5T0G9O5ArUHEf1A+YKWv0CmStX0E6/5loPaSVXnrtjG0eixjL0EewH0Eew/7jSQU/lwtBHuHykb8wyAninUa4A7cu1Lsb2j/rumltz3LAe2xg1+yAcsxF+OviwQZKN0mVXHNtqvs65TzVfd+Fy5Sk2CPhbHLSRL6zLtNNsUtmiyaYd8w2MC9gWXTma+PGRleqnOsGjbLLa7noqU7/GqGwXc2Csn632U7DtpuUPv+vI87fjV5p5br0BeFH7CnAcQPijwXbPINnYLwZHkZ9OqF8oxl8dZh+GOnG7B64rHbQ3CfjbHbSRL6zLtJlPq6ds12TTDttFe2PbVf2E8D6yUv1UJ3iUjZX5/mL0Birz/cVo03mln63W/137CvCXIPlX25UvdOleqzGLdU+NWcr+2W+g/bPfQB1lv4F9y36Dfwmc4TlXYPDnJ31h8SfqSNFcwSbi8TbgQek3z60MfgR820Upvq0nI85VCZ5WuQLrx3bE1Gjv7AtcPjh+svpNtlvsG87pqLwDypRzBSajXgGP+KoE/zboA84VoD+6jXj3/QV7jjPQZjBX8D7KFaDtYq5gDeke+jT2F/HDumfwHwB9vi55D+k3bqIy9AMcW6sxR+mZWivCMZTrmR8wv4K62I5cgeGvRc1tzpMrUPaH4wPnCnL6zYlcwWZBT/UD5gpQpkjfcLlyBe30aygnH7+G8Dx3xzayPaOPYD+APoL9x3UOeugjMBZ/H9m+8pG+MQvOz59OYhZl42z/aONs/6jvHDegDDlu2AS8qJgHx2yEvw982DMkG6XLrjj2LgG/GWBupvagrt/lgesWB+27BfxdDtrIF9Zl2mk2qWzRZNOO+QbGBWyLqp8Q3kdWqp/qBI+yyWq7m6gMx3e2a9Rt03mln644P37Ydm8WvGI8sKvlCl4E2/0cyUb5Z1euIOt8HX3YJg9crvmaS38VbeQL6zJt5tPqdVKuQPWTy8cqWal+qkfNds02OJW5gs+1KVew7g2eK/AZ8zFXgPCcKzD4L1OuAHWkaK5gM/GI+Qyfeb3Bfx182++m+DbfXIHBf6UDcgVo7+wLXD44frL6TbZb7JudlSv4C89cAec1Q+cK/t0zV/CNQLmC/wR9/tYU5ArQD3CuQI05Ss9UrgDHUK5nfqDgXNo7V2D4a1Fzm/PkCpT9uXIFOf3mRK5AzXFUP2CuQM1FEFcn5gpayZXn7iqnmXW+wf4jT67g39uUK7g6UK4A9Z3jBpQhxw2bgRcV8+CY3QB/0GS9/Q5qxKl02RXHhpivu3C5cgX3CPi7HbSRL6zLtNNscqpzBRgXsC26cjTx4yMr1U91gkfZZLXdzVSG4zvbNeo25sBYP0PlCjgeaPXbQhw3qT1WrvlJq72jPD9RsZDaa3RFCh30CdgnG5N33mt0aCLnVjG10S6o7wPt3kfTaj7IZ2fQd/OeF5QxnkfisQHPuCylsQFzUbwnQ+0PVfNk1r203yjh/WQGfyL08ehijRN5cJ3/yqrP2Iai+oy2cQO11eBPm1p9nr6z9Zl1FvU57ffpkWYlavZhRfI5J3Sg/q/YjfR/ZYfrv5pLuPS/VY6E9R/jt52h//tn0P9NDppK/61tafqP+USEH3bov5KvS/9brRG69P8uKsN6V6TQQf3Hfmf9N/jrPfXfaLdD/1FGrP+ueVP8ZJ3r8JoAxu8u/ef12lD6351B/12xt9J/a2ua/hs+zpff4dB/ZYPD8K3oWhe2YTOVYb0rUuikxfOs/wb/Xk/9N9rt0P+Q89dWeQaO59E2XPrP6xyh9P97s3e8qzPunBtaI3CosyqcN1oHZSPUDnVmU50H4DObD0Fu6Hmae6sYaQ18a8ec14Vr2EG71d0YTFvdjcG8RIJPq9fG81897T7XqmSl+qlO8CgbZVvDVOZ7rsR1Vx6eF2P9HI6a2+Fru8OAd9vsRrxrW+DNeofrcPKu7H8dlWE9150QPufYla6PEO+43hcJeF6LNvifS/rC1jdQRzLoulyL5rtq8By+0m9euzP4L4Nv+2yKb+vJiPOXPMfZQHfVVNt9V00rv8l2q86mVehvxKXWb9jOeiM91zV8fNb7N0Rcp/wR38eh7mtS/mgNlY1AGa5Ffyfhg8/oxu+4Fv07pHt572L8W9Dn30/eQ/qNESpTdx24xhylZ3VRH8dQrmd+oOAZcO+1aMNfi5rbnGctWtmfOqdb0G9OrEWrPKHqB1yLVmdoEZdrLbqdfs11j08rufLaMLaR7Rl9hOvuHfYfvnf1Yyz+HbJ95SOHBd5+KsO6Md77ab6B9uW6z8nnHLvaM4ftQ71RPozHbIT/B/BhXYONOJUuu+LYDQIe8+B8f5A6Z+7C5Tpf7zorqmirczvMSxSl26SyRZNNO+YbGBewLbZak/WRleqnOsGjbLLaLq9vq3PsynYx/8766Yrz44dtV92jjvHAgKCfd+xeQ2Vo13w/jVpjGAaYtPsp+gcn6x002Igz9P0Uw9QetX/XhWvEQbuV3xgm2uX9FI3wqp/qUbMP5L0i6r4WZbucY8B5Bs9H1Jij9HNEtGMYvrnG3RHAu5JyBaHvgRxO3pX9815R1/2RaP+uu1nZb2Dfst/g+JDhOVdg8McO7vjX4k/UkQy6LnMFPI7jmRul3zy3Mvilgzv+jfv4+EGNsycjzpMSPK1yBYHG8Wq7x/FWfpPtFvuG549qLEWZcq7AZNQb6TyF4eP89lsGd/zbKlfA8YJrHqDyd8ofYa5gZHDHO+dz43fMFSwbbGx33jzV2sHJeucm7yH9hiu25n2rasxReqb2BuIYyvXMD5hfQV1sR67A8Nei5jbnyRX4zt0L+s2JXIGKw1U/YK4AZYr08Vxy/Ey1X3PlQFvJlefu2Ea2Z998IvuPNQ566CMwFh8ZbGyH8pHDAq+KWXC+cQ7lClx3P6ONs/277o9T8zkeN9L2NKWdk33H4GS99w424gx9pxbvw1fnT124XDn2Vmd0XfcMlXdq6X5SZ05cd2q5bJdzDDi+s12jbuP+ctbPVmuybLtqjRnjAZUr4N+9yJoPUDbPcZqKfYcFrxz7fnhwst7Tg404Q+f5hqk9WfN8Iw7arfJ8w0S7zPM1wqt+8snz4e9ejFCZr32yzaNu47jL+jki2jEM33xzBTXKFSif4NK9VvtphpP3rGdI2G9kzQcoXWe/Yf2JuQKE51yBwX9ycMe/Fn/mvEdK5gpuIx4xn6H0O+1M8P8zuOPfuI9fGdQ4s54zfj3BM0X7tzOfBXX54PjJ6jfZbtUYX6G/EZc6A8Z21hvpnGXaeYH/Objj31a/s8d5TfRHnANRd7srf4S5gq8P7njnuU78jrmCXx9sbLfK66PPYd0z+G8OTtb7zeQ9pN/gPU4qZ+Qac5SeqXVeHEO5nvmBgnNp71yB4a9FzW3OkytQ9qfmOwX95kSuwPf+PcwVqLkI4nLlCtrp11zrIa3kynN3bKPrt4FdaxjsP1x39aOPwFjcfITLRw4LvCpmwf0K/5U4GGXjbP9Z8wFqbs1xg7pPVt1NxPfJfndwst5PBhtxKl12xbGt5uuu+z197tQqcu7JdV9Iqzu1lE0qWwx030RPu+/cbXWnFsf/rju1fG2X77xT+QBlu5gDY/1stWeTbVf9RgnGA7tarqB68GS9fQ9uxFnmCpr5LHMFjWVTmStg/RwR7RiGb765gi/t14i3zBVMvqflCuYmfdHJuYLTwbcdmeLbsuYK5iV4ylzBzssVLIA+2Jm5gisTPlrlCs4g3cubK3gb6PNQ8l7mCuRT5gqIXpkr2Dm5givJ9kPlCn5lF80VrAEf9k6STZkrSLfJMleQzXZD5AremTJuYzvy5ArOoLEb2zQcNZapewfy5hEqghdrB+7XSDuDMAq2+yjJJvQZBNfeqFs8cF3joN0qT8G0yzMIjfCqn9S4y3Y2DGXXUNkIlIU4g8D6eY1oh+/v214DeEcpV6DGc5futTqD4DqD5DqDMExl6t6BvHkEtrOsZxDGk77o5DMIvwS+7RMpvi3rGYSXEjzlGYSddwbh56EPOFcwDPU5zzECZSHOIPxZwkd/1Gy7mCv4HOle3jMIfwH6/PnkPaTfKM8glGcQtiNP/u03vKOTMG+EMwjDUOY6uxziDMKfke0rH+kbs+AZhHdSrsC1NoE2zvY/1WcQvgE+7J9INuUZhHSbVLZostmdziAMQ5nLdnlN03fdEteQ/ill3MZ25DmDwPHAiMB7jcBbIX4RHn1I1vvUOLeoYqEBUW84hQ76BOyTO5N3vofpPxJ5TNEdYL1Z78pR80FXHqTVfNBkomKjNVQ2DGVG03hW6/Sx7K+h+WwlKcM53jx4PxrKEf6AQ3b8a3EDtjODvC/shzoR4EDc1Zy4K4QvinSchzGNohc/NVFW9eDlmPfecexBd/YcX6H6xgt/Y33pEfDnC3iTVS/xPhh5PecrmzLaVlaFMo4D0S6Mh9iWnlvcyF9PTv585If46wL+4tFJuCx9MTNq1AXUd/N9eOfNEJWhz2R/qnymKxfMfgf96bkAk3YH7SGHTNY75ZBGnJ12B63rjvRWdymWd9C6ZZX3DtohKON7oXHM4bhtGMp876Bl/fT9HaH+qNke8PdjFtAYqGIml+61iplY93xjpiEqQ/t37SkdprJ23EG7lMb7nLmQtt5BeyX4tnNSfFvWvNqKBE95B+3Ou4P2UugDzukOQX2e86E/cuV5OK4egTLM6d6R8NEfNdsu5nSvJt1Tcx+fO2jvAn2+JnkP6TdGqKy8g9abXnkHbVTcr7nm1a3kyjlWbCPb8xCUsR9AH8H+Y9hBbwTqYSx+B9m+8pG+McsawHsM5XTRvoaixjK0cbb/rLlgHjeUD+MxG+HfDz5sG8km9HmT8g5ar2eXuoN2CMpctst522Eoc+WCcT1mW8q4je3IcwctxwPnCrzqvutK1OyHfHK6IwJ+GGD47mmVKxwQ9YZS6KTlIDina/DPesbUw8m3duR0UUas78pnIzzLW80fMVbm+bXKryt9N5rG81UCZyz7vWlsuAzgLo0ay66GMt57hHrA95ENQxnykaYHp4s2sh58BsaGL3qMm1fDt6x9cDq1B33AWg9clzlot8oHMG2VD2BeIsGn1VO2YrJpx9iAul/UVpSsVD+peQSPG5dC2WVU5nv/Mdsf6vZw8q708zLRjtPhG48Npwtet6/37duIV+1bdOnesIBHO2bdu1q0T9k/+41hKGO/gTrKfgP7lv0G5qgjAc+5KIP/I8pFoY5k0HWZi+J5L+YklH7z3N3gvwu+7U9TfFtPRpxf9Rw3rR/bMWdDe2df4PLB8ZPVb7LdYt9cTbiuFrhQphxTmYx6I70ebfiqBP8tRy4K/RHPQX1/u+1qKkObwVxUz6E73tV6L+ai/o50bxjK2F/ED+uewfcdOlnve5SLCuE3OCZFP4A4WKdceubK9Sl9Nj9gfgV1sR25KMNfi5rbnCcXpexvGL5xLiqn35zIRam9D6ofMBel5kiIy5WLaqdfGwYAH7+G8K79fmzP6COGqQx9BPuPKx300EeMWBuiSR/h8pG+McvVgPf1JGZRNs72jzZe9LdZedxQPozHbISvgw87hGQT+rclOO+m8uEuXMMO2q3W3V05f17r5ly8sklliyabdsw3Qu63UrJS/aTyyJw38rVdzlPh+M52rX6bVenncNTcDrUPUMUDw4D372jsPgXgjooayxZB2eyokZ/TBT8IP5/gz0z+7k2BN3xVgp+XyAHjrQGCid/3T6GH/OE3jhGw/pkpuNDfYPt+JoX3E4D3u+k30YcEf/sL/gxe5QyHAMb4UbI5N9K00/I1N1B7DP5U0R7lG0yn2vG750MAwL7BJaP4YZmuEPAoK85FrICyM6nsKCgbojK0nUXEwymCh/nwje0a9c7qxv340712vFv/nwZwnWjXKzzt+uQUesify66xfla7vjGF94sz2vXJgr9OsuvLPO3adKq069Z2fZrgwdeure728XqvRryXQFl31Gzr3McGv9ahs6sFryhDlu+lAn614H+AeMC6A6LeSirDeIv9zmVCDgjPtmvw60EOn3HouvFVUNf7la5jPpd1Hdf1fPK/Vwp4jEVNJioWvYRwXSJwYV9zDs1k1BvpPjB8VYK/Q/h+428l1Oec/vyMvJ8meO+Pmm0GbeqlWTveTQfRN5xONFc5aHJdpNObAm/42HbfL+TFvg7tAPm6YLQRp8Hf4/AHSpaL4BvroPIfl4h2KZmuprJVUGa6oOzT4NoxFmH72T5dbY2fvL5SzTFXUBnaBuu/GvN89R916PFZjXhXQZnhPRbqvj15rxL84xn1awi+ZdUv40fpEOsX1uN92tgvbLuXCjkg/LVRoxwM/uOe443xVVCflyh9Rh1kfVbrmAjPfeEan1AmKi+yinAp/4l9zeON8p+rBX72n590jDcYF/JYuSIj78cK3vujZptBm/p2sghpOjgEcBxTrnDQ5LroL3pT4A1fleB/wTHeDAHvHCtWosnzVzzH+EWHPzC62C70XayDSvYrRbuUTF1jkemCsk+DK2ifZyn7xPazfbraGj8sG+VbUXet/+tRsz8cojK0jZVEZ0jQ8dV/qxvryh/PbMSL+5qUzr4tea8S/G879EvZDeY5WIZKH1FPeLxRclL6dSaVoUyPIx7UuIvwnHM0+D/0HG8C6fMspc+os6zPLv2Mn6xjv8mkHjWPB5wfUXkE7Gseb0xGvZHuA8PHsfVfOcYbzN+sIt6Py8i7r72hTX2Kxhuc0/B4M+SgyXWRTtp4Y/jYdr/jGG9OB95VfozHG4P/W4c/ULJ0jTet8klDybuSqWssMl1Q9mlwBe1zL2Wf2H62T1db4yevr1RzGM7DuXKbKi/tq/+oQx+l8WYR4UVcqBcV4hH1Ee3G9i9wzvjfM+aMsW1Zc8bGjytnrNYCTE5KHw2uoD5evrNzvzzfduV+0Y6HiM4iQcd3vm11Yx1638xGOFwDrCT/2t6ZQ+F7Bpl3VQif8YzfEH+NeMlIb2I/0qFEj9tnfbfnf/+XpB2izZtuXH/jpjsv2DCydunIrRs3r1/Xhaij5hUrlApixW+VqLH1WNZN37oJ7tzRxr+tZxkuEniM7mFQpiRhOM0qsU2HpdRDWUTiW5eAP5RwHSrqGe/djvqIA+uxxlToO3rNHkG7SvD7J42PvcZ7FqfT7Yma5dBDf18v6LXR6mbuHlY3g7AaDMLiMwM4Q3j+m3vU8tg+Vlclno9ItCjGeVjybj3/Jqhr+2utbF/AbXfHbD/PRThmEw/qX+Qdv/H4FcJT8Ppk/FxK9Q6Deqs8eDhM8FwX9Q2uX9TLK5u6g2ejg94E9z+ffFjU0La5UKY8Ea+fGvxLoEOnJu8mS7RY41HJGfOkeeR8maDTbjlfRnTmBqQzF2D2g/f4vyMIF8vZ+snkfDiUHUH1joQyhMNR7gj4fqSgrfAbjlY6eO5hum1pOmi0qgT/AOjg+aSDajTl0TeK3DrPetmbAr8/8WfwK2G05nl8j2gz8sXrlAa/GnDenYIzity+0tUu1KmelHZdIdql9oBYfTW2HE1l+0KZ+XAcW6qE45rke8F71OSZpzS+Ec7ozs5H13sOYvhrUbMM80RDs4kety9fNITSZ6kgVvxWiRpbj2Wt5iAXjjb+nWcOorzAmwRO8ygqrud6bIX8rUvAzyZcyoLYO6v6iAPrscaoevHfVVHHxwJyxufdvhZg+ENZQKt+N121th8qeKmLMuQdy5DOoYKOwrUv4drXk+fYapMNcma1qzdtuH1dYrYRPa0mHbNT2OgS9SOqy6bNgf2bRJPQdHiwMtppg7DhqxL8u8Vg5aofPz5qj13UDsdv+EOpva8K8SQO67oG+UrU3IdTpKrxYyNCRbAVRdlU1f5WsWSF3qdKje93xFwVUT/G+Y0ZjbRbxdk81zP4rY6YU80NXOc2jhLwOB8xfgaIB6w7IOrxPBP3Kc8lHo6JmuWA8LxX1uCfADm41pKNr3bslT0GAHpGo4Z24RpJt4DnvjhOwOM6kclErcceQbjU/BT7mu3AZNQb6T4wfFWCf85hBzhPP4Z4n5uRd2XDal6LNnUuzUGRJg+lhztoKp01Oml+I22O/IpjDqpyP8gXz0EN/nWHP3DlKeKHdVD5jyNEu5RMj6QyzElgPmg77tFmnO3YK4vtZ/t0tTV+8vpKdTZjLpWhbbD+zxV0fPUfdYhzix8GOJx5MV77fl/y3XRcwcRPleB/A/TxLkc+wvjpp/oR4Lbw7n7ifTDyerzDO8NfI14y0psI7+4nety+fPP6Cr2jVBBrJGAjUdYqijt7tPHvPPP6j0CZkgTP67FNH0mpl9YmlAPD30+47hf1jPduR33EgfVYY9iK0Kt/WNBmK/oTx9oi0v1w1PgoS5ov6JnVfYRg48es7gFq02Dk9bzV1+oMf414yWt1DxA9bl8+q2NNMSpXEFaDQVh8rgDOEJ7/5t67StTjx/BUiefvQU7+6xQPocby+XTkweW/1Pl0g1N0DihI5wBBxzQZx2teK62KtrrWRazsbuDF1lit7B7RLiu714Hzgw6cHxJlMX+3zW2EQ29USfk3frrFN5bp/YJX6zv0AJjySLO2Bxx0sL7B9Yt6RdujeOYYA9say/dfKVbaAmVqNOD7twz+ZxZP1vsJ2dsWqG88KjmzLWaV8/6CTrvlzDb1YEA6DwIMr8M+RLhYztZPJuetUPYQ1XsYyhAOI4KH4PvDgrbCbzha6eCec3Xb0nTQaFUJ/izQwYG5je331cEHqQz7gMdD4wPlgPB8F57x2ZsCn9aufZK2qFzD/aK+4v1w4uVBB+/xw7qI9Q2u3Tp/ONFJ058DSX+2QpnSH7731uDngf4cTPqDEVo72u+ya4zkeNag7I5lqeqhjR7lwcNDgmc13ze4flGvqG4onlvpxnzSjYehTOkGn5s1+L1BN04k3UD/aTwqOXMMmFXOBwg67ZYzx3ePBKTzCMDw+LaNcLGcrZ9Mzo9C2Taq9xiUIRyOb9vg+2OCtsLvO74tnavblqaDRqtK8P92+mS9c0gHsb5LBx+hMpQp+l7ua1cfVIjv3hT4R6hdBn+hGN9c9op6w77c4FcCTs4NG11sl5otu3TxUdEuJdNtUWvaKGfOM1r93ki3P01XrnDI1Or3pLSHZWrwVzlkqmTkkqmysW2iXQOizY8RLpVpQzn7yBTb/xFqv8GPOOKwB0V9FTtwDKniMIS/huCVjanYhG3ses8YkmMb7DfeK4e5hS1UhrkFnovdDWVbqQxzC5znwNwCj38fhLKHqexDUIa6b7mFKrV1U/K9YA5e7um7n3hLy6Hhv1HkN552EZ9Ip115E6bzkYB0ENfZozv+VXO2Q+Edy4wOf3PteHLNDasF6VQFHcaFPhljIt4Da/AfBLv+BfLJWwR/VfjGcwLkyeqaDaB/y5KhtvoP5avfbW1pNddmf4Btz6KHSKtGuLK23cU78sd6gnM6jskUrq0ZcfWJsjx98qCjXcq3K14Un2m2gXQOhW8+c2glb9cc2mSEsVzW9dc0GalcWrwyU0/ek5WZs9ddu/n6CzZcz7hRZVE8BxCcmXdX1KxKW1NwRfT3AfStG/DhM1XuUtE5rCCdwwSddqeN+ZhQ2tTxJZo6tkrP8/UjBv9dmDp+yjF1TDO9SuTeksH8pW2d6Enh73UYxu7yOKLyMw6etwANphu/z0vh4bMU9uUc8mTYx2ll5IfdEbozXvjHcLFbfGOdu0/QYVxpIYfJlcPjX8kYcrg2PSBPVlel7FkOio5rSL3Pk87cgnTmCjpFQxJFR/GspmXoS36bfMmDUKbCQ952Z/B/Br7k9xy+BHnkv5VfZl9i9NJ8Ceunwf+hw5dwmI3tVDzjdJrpKl8yISPyJTlDLelLeJkH+TmS+M86FmL9qRoLjyQ67V5CVWEf+5esYbZanmxlj9/2WLZSKRZetvoY2OPfeIztPsue7fa9jMt3DDL4HwQcgx7w4K8aNdtU/H4EtDkNVyS+GTyOf5wKepBgtzhg0/xW/D6SvLfTvuJn6WgjnTS9/0lGvV+bvLPefxj0/j9I73GKxe3lKfVDog1W/jC02xdvD9WNn4sJ70OEF3XlrQksjynrDp/EX03e+wWton2KuLhPlT+N+akdPvk9/k8tMWBd7lODXwlt7E/e1RIAp3hDtN++PwrfmS4vf24jWFxG4JTUo1RX/duKx7qgs43wPubgn7cIPCzqtXupdxvR2RaQDuK6crSRTpruHki6+xiUKd21n5+qEvxc0N2DSXexPusu+jrevqlSZjH+DxLPjwOcyemq0ea6Bv8EwSOO+OFY/Mnke1osbnWrBH90wifG4ta2xwS9uG3HpLQN+wOXAJ8g2gZ/HvTHfOoPlJf1x0DULBu2gSeBF4SNH/OVLINTgY+TD0+nxXah2hjjOO1wDYc8IBzjML+AMjAcyi9YvQHBF9vu40TjMQeNbaKeosH+GGX2JNA33fhoi/InRdsi8a1LwD+e0t5I0H6iBd7HBB7l35+gskdEGfsubK/aBqZ8Ivq9Ax32kmYTSq8ed/D+JPH+uOD9MQfvSn7oP1xxg/3tM9ZXxN/G33XwjX2s2maAMPjTqgh/ufCZjDNtO8zaFJxXAk7euqF05lj4xnlDVz8hPwNRup0r3tGX8DdXLBMJHuLHfKHS2bQ4juWheFBbf5Tf5K0/ajuVr21iPF3rsNj/pkCx/0aYz928i8f+nPvthNh/C+EpY/8oel+g2P9c0N0P5Iz9eXtVq9jfyky+XaIeHykwei9DTHof4asCLdSb+LE8hskLtx9Gok2cHzf4LTAe/eJiN33l87k9LyT4+qJmG8mQb1/i0kvD/VhO3D56rWxRxds1UVb14OWLn33rlZt//PRtrO/GC3/zGftPFvAmK55nDkZezxn9RmN0sr7RtrIqlD1GZT1QZjzEuvbc4kb+Hs/Jn4/8EH9dlL0D3rP0hcK1NSCuLTlxzYwadRTtUPlhznWofGnsA77Ywj+pMY79wxfIP+Tcjnayazw33Nty4vb1D2ljKPJVE2U+/mH6P648dPkHbz27EjX7wW7xzWdb94kCvqD9Ha/8A/uAKpRtozL0D8aD8g85ff3xPvJD/Conwv7Bty8Urq0BcW3Jicv8gytHjv6B4yF1TBX9A6+X/BbZfM5tnHINnvdy4L6n+Fk5OlnGa0gPOvCwD4tEnbQ10f8XYrrfI5+J65Lxc7HgT8WkuF/iDw9Ph3tYwMVbGu0YerKlcfm6TatvGLl93drV69bcvm5Td9TIJUuDV9h416J6rIVV+vYh+ptnfgw/T+BpRVPtajoe3pmuzw6u4wXPis4pBemcIui0+5DCKUQHtRRnaX9NszSMANSulktGd/zLUcDm0ybrfYNmaUjbJedTo0Zessr5VE86pxWkc5qg0+7+5B8YR4/Lcsu6iwTrc3YlbafBDw7XNNN2vLHeGPw80Jt/9NAbVxvVjjfXbkjD9WALXJcQLqzPu3sedPCs6LguBujypOPTHhedndkew6V2hWEf8I95qB33huuhFrhWEy51SMG1k6sicCo6rh1zrh1jWwvS2epJZ6rac19BOr477U4tSOdUQadf1Cvq1xXPrfztvkdEDW1TF7m4dhgb/Gzwt/snONXOrje6nNuxsoN91qo/D6f+VCs7rv6cyMxAfx7l0Z9KNmk7l5Cuq6/VxRoVgcu125flgPBqTGljtsj7Z8w4Y5wzMz5xmNF1OUb8WNvj2d/eyXsy+1uybuMJJy48+7+nfnfeuiktczQDiUaNq2wIH9HfXC/mLe0EGsLGD+vPwwTH/W7fGb8PT61gW5UrX/doSjujyM/XYf0HUnCl7dC2/uGDyacndq52aKuYTF3Y4IoH1OocwnWLNkxLqXdrpPnDUyK4243bbPBnOdq8tUWbOX5XsSP7JobrFm3oi5p1AHEoGfMPTmfVJ6w/VWPnIqKTNqZdRGNaq93ntyXvvPv8Bwsn662iMU3Fgu1uP8ev6vrd2wAmbW5TTcHJK7kGf1XS9oIrKzLLytlhlRGN2/c26lPVdlefGvw3oU/f7tGnLvtQl7m6fMEWB7yaK6rcjytutP7hXWyDkc9T+aaPjiL+GvGSUR8m4g11YRK2L2+8YXi/AQ1C/lvFG1zPFW8wbJrtcQzwEH1vFW8ontJgs8YbKI+HCTZrbhLr84pgzgvoB1nm3ZHeZZh2mq0r0uNk2gnsSgp+znNZ/WrULBscm9gXbYRY4nNJLKH64vQU/qLIry+w/lTliU8nOvcFpKNuUlAxDutw1hgH66eNB2k6uCF5bxWrfIDGNVf+Guly/vohGNfupXHNd93Ddbk5tz/r5eY+cUwr+2EZ+cYxBj9OcQzH1YOR17OSd+8ZDsSdM0Za6WMTiL9f0DO+aqLMZ4fIc3+y4ItDG972MI9Rxgt/88m1nCvgi8Ur0YX9RmN0sj6udMdPFcoeorIeKDMe1A6RnPHNhT7yQ/x1AY873LP0hcJ1fk5ctqtDzUl3lq9Iy1UYLh5rX3LM27Ou4anT7hzjcxvZ58TPYKSf/6LH8Jn89xC0HqR2G+xr0O7P00+tPCh4NR/R7aARiW+VKF02TEPtkrk9auRtqwdvKn+COO5L4TPGodbcWG+z3hDhyr0gnWUF6SwTdFxjEv9rdPiba/1uGdFJi2e+kGF9KH7fmLzz+tB7IZ75IsUzWD9tjbIS6diYfaDVTzv1yv7E4H8b7IpPcHWJNm8EvtL0DNuFY2paXuYrU5CX4TZVo2bfGj/LRiPZpla3fhi8ihlcF1mq8ZNxpeV2OYa2tn3t6Ml6f3pEtvafM6px/uVRkzi/mhHn8hSc/3TEJM6vkW2g3pwZaXrx4zNvxPocs6GuZsn5WP2789WfuJgSb6hTfsXwF53nIq1a1CzjPPkuxburH3qAHueHFK6ejLj6RFmePqlG6e1C/P0OXhSfHGMoOmfCN56P3OPgC+HNhlA3ra7J6F4oyyCjLld/3QM4DX+By0JNPPsSnLnArqhZxHen4Iro733pWzfgwyfG/VAybg2IZl5BeFUX4TdWY6xvcIrOvgXp7CvouHBdIXAZvJoG7SvgrR0fhPpWt2DqYkIN7xW8qHC5gBqaeOYADEYBXVGzRX0wBVdEfzPONDXsFjT4jIDLCuNnQOBgL3yvg6a1NX7qor7B2Shv0ct+yaV5BT3Ph8zb4k/zmZwKZuQ/5DuC8jX/SM/4Uj9P65Ot+of6sX9y5dxlv+8yM9dKnZr9XyngC5rePSpbhbuc46cKZfdRWQ+UGQ8qW5XzDMw9PvJD/HUBz9mqrJkfdYdfVlyWrUL3abYzVbbswqUySxXiuTfSK1XsKwz+oMRX4E9/dEfpcojEt66o2U+sGt3xrxqSFkSad0Xb8MdPXdQ3uDb6qp6svqoWNbc5T7Sv9FbJxdquMoi8Qz5++Jx+1tMWnY4LdbM/atbfSsq/Roe/sZxDrEhyn4XA9WAAXCrreBy8Y5nh4m/cL1h/K5XdK+io1doPUhnKzXyh2tU/j9qFNsn+O6sfqgr+OGsQv2OWc9mRmiZmu7AuZ5wM/nbIDp17ZHobfXZyIXxaxvBCiinbuZMrTXYXZ5Bd/NiJG5bdZSC7Sxyy47FfrSyorCLfIZ/2E7pYFkXuHUwqs+5z11HBlVLvsS/0zi61i175mIJ3ulSNnusnJZHejEjLVN27xJkpNV9Vvo5XdXFcS/sZ1/j9aHhP82fYJs6MK/6mym8qOqsK0lkl6LjiRB9dV3QUz6182W3ky9TqNNa9IXnnbP9S8GWbyJel+Xj+22d+YfTSVrseSOHvTphf8GqXavMNDp6RRhQ12w2PXQb/Xhq72nHXg2sHd0G6Xb4+2PDXiJe8PrjV7gbcXTsreU9SfRdsGFm7dOTWjZvXr+P1k7Q9lhXCit8qUWPrsaybvvUQ3HmjjX+b1nZH6Q9aBXrZKPLb56H2PqhZ+X2CLu91QHifPSPGe7ejPuJI23/TnVIv/vsuUSfkGYaQM5o27rnby9cyDX+NeMlrmWr/lYqOODLEumqvKi7sYBnScUWniOueQLjihzMDJa4SV4mrxDUVuFx79HgWFj98VhP9IM+csi4qY33X4vWygnSWCTr9ol7eMbnu4FllW1huWTOQat9fqxna7xypafrO0Az+ZJih/f6RjTyrGRrKAGdA2A/bcYw21+0zHqAsQ3wxEM/SHqBf4kC59oxO4m0Vh8TvtnfR+oHPE2AZ6oJvH32V+kjd/YV1ec+owb8Z+uhrNIvG+j77iRQ9tsPeFPgq8Wfw3xCrdIq/B1Lope2hfVsKvW8DvbtBH7a3c3SyPmbhtuOBsixxtNI79DOsdyoTpPyZy1+ojJbKsvLKrNoLqfabVqh+b6T7gPcJG/wPRJ/76jn3q8H/o2e/4t617XigrGi/oqy4X9WqN8Jzvyo9wP5yZeruJlx3C1yu/d+tbNnwsW391NGvav838sn9avD/5dmvuG9zOx4oK9qvKCvuV999lC49wPHBZKIy6x+iMnWG0eW/UQ98+hz7J81/75mML9jnKoNf9eBPyS3OwO2VvCcZuNWbNty+LknBRfS4Umbx31tS2Jgl6kdUt0LfZlGZcp+uzTtGuzfSKSt2nxO8CpG73G/8uLZ8F9x+7p3ENfyhtoy3cmucKnKZmWsqsxNUNX4su1sRbHH9iHBVxLco0luQES9HgS7vpkSl9mohvOHjdetDhEozTuRBzYgMXkXuODryfhBsA98wifUeSKGDIxqqEY9oBn8UtNU1ogWa+cgRDWXEI5rKLLhONqv1bJUtrRM8yl6NaHzaqpUZmntVMyuMKnlmpfTFFZm55KP0S+1rUHsrXLNgg2vHLBjbw7rg6tv4YdmoW2uwvzlqxb0FnHlCW+LTbGrW46sLmO34nZS16lZ4DV7dTIFDOM/KDX658AGGU63IufRRyUKdYlYreFupDOvhvoLtuEcny/CWte3tg7IM+jg9ZFYmfvLaqlrl4T3dOBa4sji49n/bFO/B4vFb3VyKvPLvShn82yBrtOGoRpzKxl19oPYfod2zv1S/m+bC9UEHbXVr5zYHbeQr7fcQI8En/t7Pdlqjk2Umm4K20qNsBf0z24rLF8ePj6xUP9UJHmWTdT8Y/46k734wPM3M+qniRd+xAfddXky22+6sPcfEd8AY8QspMbFvNtjg73KMO6oNrnGnVYacbQt9H8fZKiupfB/7ReWvlR9hv6h+vw/h036/795EfgVvMZb7rdJ+N7Ua6diL9wAb/NPguz98lMbZkxHnRzznLIF8XbXdvq7VmMT7VLFv0vYbIi61F5XtrDfS8yXDx6ttjzsybehv2aeiv2WfukXQdZ01iPXmcwkfHK/F77iC9THSPTVfRp/Dumfwnwd9HkveQ/oNvrVJ/e4m208UufVMrQoanNJn8wMF93x772nn38vLuYfeeVupyhkU9JsTe9pVrKL6Afe0q33siMvGgqn2a65cTCu58vkgbCPbM/oI9gM+MZmilxaTfa5NMdkyisnQvtj+0cbZ/tXNpWoOwHGD+h169EE4ZiP8F8GH/TnJRumyK8fS6nfoeU6vfofehcuV63tCwD/uoI18YV2mnWaTrtsM2zGfwriAbdE1l4wfH1mpfqoTPMomq+3yPAzHd7Zr1G3TeaWfrXIubLtbBa8YD6gbZVZHjTTV0g5+43EW6xucorNvQTr7CjouXKsFLpdPdF19oubUBc9/T1x9otZ51FUrBa4+MfEcCjDxd776BNO+96bgiuhvxtkN+PBRKlFN4dPotlIJrJ+mEjZcxI9toozL+WiRwf8nTTPvobYNRl7Po64j4oY751H+RyuEL4p0qJl2PA35UtcK+Fxz8sf/9P4PX73mO3/pMilXelCl+y8V8AWvOXlIDWN8lUkVyjj1jkOR65qTnG7gIR/5If66gOdrTrIeacSyS3LismtO0FXyZuJ22z5P27uTs6uYxptqXiZCJsGLawjA9B9v/kbeXRu2uV3t2hh+WUE6lwk67d4YfhnRSdsMvM/RUUPb7oUylf69MXnnjZdfhss890ve1TYI5FGNPzh2xQ/bK28MZZgHUvh7M+gnH6lVbb7RwTOm0aKo2S9windiK0rCQ0GfKlO8fOVXG6708d6NtbOu9Ml2pJa3KKNUECt+q0SNrceybvrGm67OHW382yY33VH6g1bBlqEkYThd18Sr0TfLRVWIV21M4IvzXKM94lCTEMOh6sV/Xy/qhLysYKqO55pl4gQ3g6V4/3Sl4a8RL3kt07VBJH647epSF7VBgmc7RY7UPhQQ15ZAuOKnPFpY4ipxde7RVXUhGG8mjR/+ifp2z7wUnVUF6awSdPpFvbxjX93Bs9o8yHLLeqkh1ufLZtJmQjcerWn6zoQM/pdhJrT+6Eae1UwIZaDOEbTxqJncJIly7RmdxIt2sJ2fqLnf7Div65iO0gXfPrqD+qjVkT4+Xmzw49BHd9Fs1XU01LVRHOmxHfoeXTX498Fs1XV09YMp9NTR1fjhn5M3+LuB3hQcXZ2p9A79DOudyrgof+byFypzpBaz+Cic6/hj1mOt6iicOlfFR+G2Cn3gsYh1I40/JbfAR+HuS2FjhqgfUd0KfZuRgsvwxN9w+upzFE6ddmUX8bgQuavL4qc8CrfLHYWzrExFsMX1I8JVEd+iqPVROB5VXCJWolJeBOE5R2/wLwqVdnlY1w9oq0gAu9d1FI63xWG9D6bQUYe744dHNIN/1XNECxRJyRENZcQjmm/mxOBbbYlmU3NdGqJmNr5m6HsUjiO10EePWL98jx65ourd8egRDkdbiY6Konx1AWdPN6asMaXhTVujRR+AQ3jakYTfEz7AcKoMtEsflf6qrLfrOnG13QbXA7fjHm3GWVAf+5U+YvtZH11tjZ+8tlqPmvWMt5LiWMBhZCu9cekjrvHtQzM+pLOCaGb9SZUVgn9FZ9+CdPYVdFy4VghcBq+2Aru2i6njaQW3X3e5dE9try6wXczEcwDAxN95uxiq8CMpuCL6m3F2R+7tYth196TwaXRbqYQyHUWnWpBOVdDh7SCVJPwtuOR8t8+iWc4TBndXCF8U6RlV2ukK5EuddvDZZva1z53+a3u9/08HKlTfeOFvPqa7UsAXNM9RNTzxydQqlD1CZTjEGA9qm1nO0ymjPvJD/HUBz9vMsp7IwbLzc+KaGTX7np1lyxOnyRJbVtvM2s2LorOqIJ1Vgo4Kiyop/xod/sZ0FM+tEtwz50UNbVPTX1eC2+DXw+957+1IRaSFDpVIb8divTZ6vr9wYPCzQad4O9YDos03OHh+EGgw3fh9XgoPB9IYlXPzhdyOxVNQ5IftRG3qUb8YoOzkAQedywvSuVzQCbkhpu7g2TXu56WDPtVsTp32fCu8Y5nR4W9MB+tvddC5pyCdewQdlRrCaVPBmKm7YBwx8dvVrW7zMfzqJqEseoC0aoQrI+/OE6muTQYY02Ab03A9mhFXwdhpok9a3baF8V4aL4pPTisVaXNPQFy8MUzZ31sFLoP3/fUrdfrT6lrf4em9PNNm1Xfq1GOBabOJ53KCs/0vXVGzij+agiuivy+nb62mzahS1RQ+jW4rN6ouTJkqd90qHFw1T9NMCwfN1XMI/z+Omax3qeN34nupjVlPOmB914kKDlswI8rZUnWde4XKkD/XSSC10tQt6KghM+cPUVUKhpcT7rnV3hvWqbwhGtIK9aNYindX6ImhGu+5VbgezIir4Km7iT5x/dgX4u938KL49LkIphe++WTklbzVCpnVNRnlDJe6XDJCWzD8BYYmE888grOZaFfUrEoPpuCK6O959K3V0NRud6XoDBWkM+RJZ6ra80BBOg8IOi5cQwJXaUoNz842pWoKn0a3lUpg/alWcRVhYKKxVRT4AEWBeA2oTxRo8L89b7LeVnjnvUqI6/6osQzl+BHi/+5o8rE+LXjPgPe2N8NfI14y0puIWHx3nGY7c8jTV5QKYsVvbE1Y1k3fuH6V6pkVd0fpj0nM6KpV97sFThXn35tSD2URiW9dAv4ewnWPqGe8dzvqIw6sxxpToe9obR8WtHlP9XOQ4v4gpbgVLZRHq33DDMM8TOz4c6TZ74E6ql1szXzTB+qWLZ0x/V8BL/OpeZp+JOhz+9B79qbwi+1B+NdABryRV3n+KOUbygDrpv3N54vxHf9Wuvhhgv9Qi7Zz/xv8/3D0f4/gwfiKH5Y/86BgFA+fEzwIr7l0w613puzhRU1TXo57iXuiR+BJe0wacR3TXpYOWwfTsb+VBsQt3zt5nwjN1q/blLZ/mduaNqJ0RfrpjzRv8bOztqT35KPn3JKO7cu7JT3NSlvRKbglPW3QVs6C60dUtyK+RQnbtyRHKXbmmuQ9BemoJCLjSguLr03eqwT/R+Cg7k5Zi+4SOOPHkt8G79oWH0XZt06yLFXCz0XbtXb/cEZeW60PceIW+XskI6+XTDGvDwheXWuPBddRvV2n4Q+1dun7qyvZpjV8iAClgljxWyVqbD2WsYfkqcKK0ca/80xrWq3i8rQmbVkrTbMi8a1LwD9CuNLulu9Ooad6FOuxxqh68d/vEnWKrr7HDw/GjwbEtU3gKriiuo+vZRr+GvGS1zJ974C1tj8ueKmLMk45qHt5Hxd0FK6HAuLaEghX/PA1ECWuEleJq8S1q+FSB/b43m0cP/nqmXZfoaLoLCtIZ5mgo64iyRsr1B08W3tw7Ga5qV1e2xx0sD7vYsSdy7jAc8wxmibOZLEu7/o2+Bdhm8/8Y9LbiHLe3q7RZp7b8XuQGOP0jE7iTbMfjOHskKeKJfgQIfY13vfv6oPTqA/y/v7iVuiDxdQHWB93A6bZjaLHOtKbAr+F+DP4JQlP6moZrP9wCj2UB8r53Sn0lgE910F8o11Q7/Zp928vtNJT3tajfsPCcKmTK+o3USpUvzfSfZB2gmel6HNfPed+NfjVnv0ayJ/sk/WqKpVZc11oofQA+4svKMc+T8tEIi7sa59+VVe3cr9e4+hXtUkA+eR+NfgRz37FrXTb8UBZ0X51HU5X/eo6nK7Gb+xXk0k9ah4n7yZcru1+8ePTr9gH7KMNfr2jX1WW2+WHDX5DB/hhlJVPv6qVAN9+ZT+M/cpXfOFYx7Y8VT763aLPOeZnv5DGn5Jb4Cu+HklhY29RP6K6Ffq2dwouwxN/w7Qqi9ya2xvpFCiL3OA/IESuzFTt1VIHRQvuFPdeFDD8tahZJfKkHl2h53bGkn+z7mLOOiy2QVXjx1YLKoItrh8Rror4hmVKVX2vJMER+gHagocqxDMF5flU5G/wFoGmRReGr0rw2xyjkCsKjqJmb93q1934vDe24Qkqw3oPp9DB0RE9P4+OBv+05+hotNsxOqKMeHR8Esq6BTzL+6MC/kmA4azSR6GMTRpl/ATRaeU6WP+VnqrZt4rGXdcztZqVsX6pXy4cEPVcmRKDa0emBNvDuuCypfhh2bh0B2VTj1rrCdol/+Kjyy/Fj0sXMLtwDGVNUP84O5f1wm+sb3CKzj0F6dwj6DAu330qBv9rwkcZTrUK7Nof0er8NZ9qcJ0DVr82zP8aHf6WdocK9lXIlWNXRO1aVc5LB/3MQ0TnsYB00nwW+4aidNTKshq/itJB//QA0XkyIB30dXiMhcdEjOmMj6cEHzYFeBq+ZxgLqj7tQPw14iUjvYkpwNNEj9vHU4BnBC91UfYOeMcypPOMoKNwfTAgLuvbgai5rxcQHRVLfdRBZ4EnnYUF6SwUdPpFvaI2omRjdJ4OSAdtZiHReSYgHdSD/YjOxwLS+RjAzCM6WwUPsT/9F4qDPw5lnOWKH1sBrhL8dLj/6d8onkJfgTxifYyTnhLtYHr/mdAw//cs1Mngj+RdSoarleyiYxvb8hSU+cjO4H94KtRLcA6IdrFtj0HZ01Q2DmXPUNlzUIY4sCyCNuA31jmsb3D9oh6PV8/D9wz91eNjG4i/FjW3Oc949TzRw7bHj8nF2veJfPSqRu8FQU/1w4xIyxTpGy6+lhv97LNUhr7xOSpDfzZOZWjfR8M74kxrE++ARf5Yv5G/R6hM7Zx13Ymj5uiPURm2meNba3MP4Ykf22lTJdhDj52sc1DyrvwN+/GnBG4r+7goi/H/0vGNbUGfgnLEsvjpFt9cY+izKbjwwB/O3dgfGvxQIg/T6zHAm8GWrje5jMNH9kM5/cL1vn4ozSciX8pH+dzluu3IH8z61Jp//8usvtvl084W8AV92rUql2W0rawKZc9RWQ+UGQ/qLtecY8q1PvJD/HVR9k54z9IXdVHGZ3zy4mJfWBTXtpy47I7Zcag/RrhULg/HC9fpCObr2Ra4+Oe/sT77sLEWuHhH5LOija65S0Ef5x0PjSXvtajZb+eJh8aIHreP5++q7+uijPV1XNAZF3QUrm0BcT0bEFc78pkqvjmDeM56d+EZgmeVNz2D2oMxIM6Xrj5W84PzJZwPrx7d8W+V4P8XzJeuofkS0nbFhZxzyXr39gJPOssL0lku6LQ7D845l2cD0kE7Wk50xgLSGQMYzrmMB6SDds2x+qOCh1hnN5IdPAdl3aLuncl7leDfB3bwTocdII9YH3MuKnfE9N5NcXnOeEvmXDAedMnuPSQ7nHspn8ZzDIO/FmQ3SrJT98wquT5LZSqvMhA1y4pzYCoOx2+uPB/LDeuZfAvG794xhuGvRYX0YyLG+ATRw7bHD89PXshHbyLn8qKgp/oBcy4qz4K4OOfi+m0I9I081xiDMs7HjEMZ51webdEmn1PH/LflOTDnz3kOg70I7OwJynMg/stHG8tQxz8KdJ8iWx0DOM5ljAF+V85O5TIMLuTYpHKzHKONR808jzt4xvrjVDYm6PCYzv71hWM1P+hfMR7gGM3gF0O/v+zIaY9FjWXIM8doY0DXpz8XeNJZXpDOckGn3TENx2jjAemgfnKM9lxAOjhecoz2fEA6OA5xjPa04CHW2V8lO/gElHWLuhyjGfzXF0zW+4LDDpBHrI8x2rOiHUzvSxSj5RwTZYxmuFrJ7ssku2ehzJVD4TzwF0B2v5vBh+CYPE5lKI/nqOxFKEMcWBZBG/Ab6xzWN7h+Uc/ka/31EnxvR4xm+GtRc5vzxGgvET1se/xwjPZyPnoTMdonBT3VDxijoUyRvuHiGG0MYHhdbBzKXqQy9GcvUBnaN8doY5G7TRyjKd1nXFX4puKsKsF/G9aj/jfFaWqNJ4a78bhGuHGgw3qdc53Fe3+S4a9Fzf2UR69Vbhvbx/nN5wUvqu/vgHcsQzquuR/ieiYgLp7Loo5xHJZ1jXCBJ52FBeksFHTancPiOKxd8RHvT2pXfMRx2CcC0sExkeOwMcFD7GO6jpv8jn4VY4kxoMmxhMGPQCzRk+BU8zEe93nvBMNzHGbw0xIa5v9yjrMyDuN4YgzKUHb9JLtxKPORncGfDbKrO2THtu0baz1PZTheIw4si6AN+I11DusbXL+ox+NVzjjFOw4z/LWouc15xquXiR62PX44DvtkPnoTcdinBD3VDxiHqdgLcXEchn52nMrQN75EZejPOEZD++Y4zGiktckVh42n4PKNwwz+CPIbOeMm6Td4Lwq2l/W/jNd2vPO+jiIxVtG8fxmvNf5rdPhbGa+FoZMnXjsnULz2nVMm662Ygnjtog6I11YGitd+G2S3mmSHtNm2UU4cr2EcxfEaygpxYFkU+eXNsP7uljcbh2+7Yt5M5aWUb+SYDP0Z581c8dpY5G6TT97MN8fFNNPiuitGG8sN/pbjJnGup7yZ2o8dw/24zK+9YfJrrvMLHK+pcxJPO+gs8KSzsCCdhYJOu8/lcbzWrnN5HK+90dY5xwQPsY/ZQv5NrXOOAU2OOQz+Rog5HnLEaz7rnOOiHUzvMYrX2rnOOQZlKLsnAsVrF4DsnnLIjm0bx0Y+41euc+54ynXO9HgN/ew4laFvDLXO+UyLNnG8hvw9k4LLNw4z+J8nv4H2VdRvGC7X/SF9oj3tiNcMf414yav/qu/U2QF13sPqqjke59fGBZ1xQUfh+lhAXGW8NkmHv3VivNauexR21tmBMcFDHB/8EcUc6uzAGNDkmMPgv3/yZL0/deSIkEesj/HamGgH0/tL8rs4ThT1u4ar1dmBv0qZy/ueHTD4PwTZ/S+SHdJm2x6DMtedDB+jMpQV4sCyKPKbk2J9lpuai7yRzg6Mwbdd8ewA+lk+O4C+8XkqQ3/GuZNxKPO5rwHbxPGa0n2V48JzBJzjcp2RzRkzDfjqIMdMRc/IqphJjdfx9bNzk/fk+tnl6zat3Hzt+hvXnL/uzo1Lblm7cuT2TTeOrF+ydu3t6zZuRKaR0HT4juX4MIy9bxPfEcfHWjSGlQE7iwOzsRa4+IA21h8jXOMtcPEBbayPdfHvnqiZTzvg0uWBBw0tja/VxBca4nOE63kHrvjdNp+rwSQt4ZKG62cJF9bnxUVMFjGfLC8XnjQHiny9h/hSDtNwvdQC162EC+u/RLheboHrvYRLTcL5756omU+WlwtP/N8nW/D1PuIrbfNN/N+nWuC6kXCpzTuG69MtcN1AuLA+1sW/e6JmPlleLjzxf6+04Gsj8fVpKHuFyrDeKqKTdZKG9adqkraK6LwSkM4rALMf1Iv/fhXKxgCH67CUDf6vwfd2JEwMf414yUhvYvB/jehx+zhh8rrgpS7KOBH2uqDzuqCjcH0sIK5XqT1pk7CT5jfSfAbKfCZhBv85mIQtSHCq2OMVaqOKY54R9CrUrl4Bj/iqBH96wpP6eY1XRH2FG8dTV6KjL2q2r3bYiOGvRc36k8dGXiV63D62kdcEL3VRNg7vabb4mqCjcD0XENcz1J40GzkvkI08BzZyYQfayCUBbARjKB8bybnw5G0jvPBU1EZULOuykVcFL3VRxhvrlS2+KugoXC8GxOVrIyOBbOQjYCNr22gjJm9fGzH4GwPYCMbNPjZSJBmG+Iwf/Ib4Q9nIC0SvlY28KHipizKcM2EZ0nEtjiOuTwbE5Wsj7wpkI5vARt7dgTYymtFGFO/tmHup/NUJ8J4mI6W7dVH/Y1T2tKDTSkfun6/5UToSv/NPAU9cqAQ6ssWhI52wsLq4IJ3Fgs5UL6y2a8FzMdF5ISAdHFd4YfXFgHTQV/peyvYc2cFLUKbsgH+O2eC7wQ5ecNhBWs4SF1afEe1gep9KaBTceCQXVg1XK9m9Emic+ZuTJuu9nsGHYEzPPh7l8QKV4ZjMeV+VX8VvrHNY3+D6RT2Tr/UX5i3bsbBq+GtRc5vzxFq+Bz+tfa/kozexsKrmEqofcGEVZYr0DZdrYZU3K6Fv/CSVoT97mcrQvn02wmGbfDbCuTbY9Ane2xHHG37TrZwLtBO61Spe5Dj+BcGL6ptReMcypKMOSytcTwfEZWsM5Saz5m+dEAvxJrPdJRb6VoZYKH54PDf4D8F4/p0piIX+vgNioe8FioVuAtn9QxkLuZ5dJhb6dD56E7GQWsPOEgupNe03QizULfhDOLQ9lU+KxLeKgx7T6BJ13x818o1lFxKNrDmgCwW/bczrdvva166S1+U19CK5WJ+YZ2cd+mjHBsYL4VugTbTdrn5wXfidcy2vy+i59nYhvdif9kbNfZi2B03t3cL+SrP5vPspX2iBy7WfktcBX2yBi/dTpm1cxrJTkh8gi/3w3OMbYWwv4FEAc0Tyrg7nYzx1EsGpy08KXujhbXuGv0a85LU91Q/qwGGsm3tEbh3BPhqH97R9oi8CXfuWprPIk4/OZu1Ttak8hjvVATcu4BSt+G/c92w4OBZflOCI5fzq4sY2It0xeMey+FGxv+twhuuHCxcUpLPAk87CgnQWCjquw5E+tqboKNkYnXb9uPob/QeD0y73XnX85He2Ndd4wYfe94T57aX0A5VjQDvtUKfvATSDvzKhMRUX66XJ7mqS3RiU+cjO4H9w4mS9axyyY9sehzL+8VOUBx9Ow7EBcWBZBG3Ab65Djwa3uxxAG4dvu+IBNDXWKd/4PJWhP3uOylw/GLytRZtcB9Csbny46sDkffJw1fnr7rx8ZP2Na0c23bjhlkvW3bZ53cZNVcDM1LEVUaQ98Vjyjnj4qdDfXVT2KJXjKQf1+Fw1gBbXjsjX8Ie6amCc6HH7eNb/nOBFXVXxAXjHMqTznKCjcD0bENdY8l5e5dn8jem4rvIcC0hnDGA40hsPSAdtkyO95wLSQX3zjfQeoWhlG5T5RCsGvxWilccoWsFRA3lE3BjpbRPtqBL8UxTp5cy6yUjPd+flMx6yc60CGfztILtnSXZIm20b5TRGZeraHzVj55/PVdlAtTqvIoIp2LXgHelNxa4FjB040ssZWU5EeiqyVP2AkZ76yUjE5brKk68aGIMy19U+T1MZ2rdPpIdt8on0TLe2CjpW9hSU8c/pfly0Oba7X3LY3WPJe5Vof4V8ENpChj4/o5/oGA7EnTPLf4avvaStcCBfasWh6sHLSd/64j7d1639JPt844W/dQH+NJ90loAv6FsW9RuN0cn66NPipwplT1NZD5QZD3E28bnFjfzl9EWLfOSn7BXhl45OwmXpC7VyjDaSBdfMqFGv0HbM/tC+H0/efeZBOW3Qex5k+EPNg5RPdM2DlMzqooyvyH1M0HlM0FG4tgbEZb5Z9TPPg7YKOlsddBYInhWdhQXpLBR0+kW9Ssq/Roe/MR0lm6nOeD8WkA7qAc+DHg9I53GA4XnQI4KHePz/PsXyuArVTXXjh2N5g98LYvkfOmIK5BHr4zzoUdEOpvfPUzgPSpPdv5LsMK7ykZ3B/8sJk/V+4pAd2zaOSTyOoDweo7K0nURYFkV+u3WwfpbdOhiDt2MeZPhD7dZROSM1xlv7xvLRm5gHjQt6qh9wHpT205mGi+dB6Gd5HoS+kXefoz/jmAvt2+fn2rFNPA9S/JWxkH8sxNfPFolfPhoQlytGKWOhRjplLJSPTp5Y6NgTJr+jf88aCz0B4/nxyXs7Y6FTEho7MxY6lWSXNxa6C2S3iGSHtNm2Vc5MxUkcC6GseF6fNSeM9Xe3nLAarwrGehOx0JiglyUnrOIiVyz0CJWpXL/yZ5wTdsVCj7RokysWwrr4d4+AfRjai7CrwM7uOCGd1hNRY9nDUPYklfnaJ+JA+aadRr+W2mDwb034jnONn1mscXZF7jUplfu0dvQZXSjLoL+/HvP1wOJJOqgv8dMz2sgzjn+umMrgnxDwqHMcGz4BZRzPKX3E+ML0UcnLeGyHvJAHH3mptSlfebHdo7yeIlwq/kUZuuRlPLZDXsiDj7wQPqu8TAZKXh8nXK3mOOcTr4a7N9I+wfBVCX4T+AS+Lcfl4x8WuNE3VggHtqNLtKOfyrDu9p2mSTA3VXkejjXxZwBZFxBvleDfD+PGNpLNWDT5+KxvjQv4MYB5hNrj85PUiOtRB+3nBPy4g/YYlPHelXH6O+2nGLfTGp0sM9kU9AM9yg9gvor9wBiUufY/uWQ1BjBsS649a745p2epzDfnhDc8bUuZk2A70nw22wPOZ3iuo+YJLt1z3QShdE/lWJX9s99A+2e/gTrKfmMMythvWH9m3aH+HM1R27FDnfW7Gmn9Ttt5/svg215I8W09GXG+DOPR3WCj8aPW2wv6gqryBWMAwL5gHMq6BXxWv8l2i33Daw1q3RxlyjGByahXwCM+PuH0C54xwRjx7psDd837zB5ivfnzhA/OCcTvmEv5n6R76tY6ddMg31r3l6DPv0pzvBB+43EqG4Myn1/FwG+u0zsG59oLW3A/uHcuxfCHukl9nOhh2+OHcyk5/eZELuV5QW9M0MNcCspUnaq0sWCq/RrKycevqbUmn7196CPYD6i9qOwjFD30ERiL/3lKDhrb4RuzYP76WLJ/tC+2f7Rxtv8xKOO4AWXIccNzwIuKeQwv/7TaN8GH/Yhko3TZFceqvaXPAwyfDENd/4QHro85aL8g4F0/cYt8YV2mnWaTyhZNNu2Yb2BcwLao+kmdH3HJSvVTneBRNllt9zkqw/F9jMpQt8eTd6WfrW58Y9tVJ8oxHtjVcgX/AbY748RGnGPR5FPmChrrlbmCZtttd66A9TNUroD3iJW5gsn3tFzBgUlfdHKu4GTY73hwim/Lmis4LMFT5gp2Xq5gPvTBzswVXJLw0SpXsIB0L2+u4DLQ59OS9zJXIJ8yV0D0ylzBzskVXEK2HypX8H3ag76r5AreBj5sA8mmzBWk22SZK8hmuyFyBRtSxm1sR55cwQIau9U8Sc0VxqjsGcG38gccTz8PvKh9G5wrMPg7wXYfINm4ftU5frLaD98cpezHhcu1x0jdVPSCgzbyxTejsy0jn1ZvqnMFaJ9suy6fGT8+slL9VCd4lI2VqXHIysag7HkqG4cy9hWo22hjrJ++e5vUvRq41+iZNucK+DZ1NWdR9s9+Q8XbrtvUlK6z37D+xFwBwnOuwOCfolxBzptQZa6Ab+7H+ySUfvPcyuA/A77tYym+rScjzrEOyBWgvbMvcPng+MnqN9lusW/4Lhffm9XYznojHUPwXkOD/7QjV4D+iOOMMSjjOGNc0FX+CHMF/69nruDnA+UK/gj0+X84cgV5/cZzVIZ+gHMFasxReqZyBTiGcj3zAwVvMPTOFRj+UDcsK/tz5QqK3CAd/6d+yTftRmclU3XDeCfmClrJlefu2Ea2Z/QR7AfGoIz9x7iDnprfoY9w+Uh1Q7u6FwdjlkccuQK2f7TxMSpDfR+nMpQhxw0vAi8q5sExG+H/AnzY/yHZKF12xbEvC3i8JZ/n665f4VW4XLkC9es1Lztoq1+vYV6iKN0mlS2abNox38C4gG1R9ZP6ZQuXrFQ/1QkeZZPVdl+ksnEoY7tG3TadV/oZKlfw8zR2jwFcO25XThu70XbRzxhejn3/GWy376RGnMo/j8O3rHEnz5nUfN2Fa8xB26W/ijbyhXWZNvNp9ZTtmmzaYbsh5wdKVqqf6lGzXbMN+t70zPbpe9Mzjrusn2NRczt8x90xwMu3rbv2XcQPy9OVZ1W6Ny7ap+zflVtjv+HKaWPfst/gG7wZnnMFBv+mpC8K/sKOzBXwr8phPkPpN8+tDP4Y+OWA2Sm+rScjzjkJnla5AuvHdsTUaO/sC1w+OH6y+k22W+ybccI1LnCpX31hO+uNdM7S8PHa1BHQB5wrQH/EeU3fm+fHqUz9+kWsN+clfPBaTPyOuYLjSPdUXh99DuuewV8I+nxC8h7Sb3DeUuWMXGOO0rO6qI9jKNczP1BwLu2dK+BfY8qZm3D+GpOa7xT0mxO5AjXHUf2AuYJWv0DmyhW006+51kNayZXn7tjG8aixDH0E+wH0Eew/nnHQU7kw9BEuH+kbs4wD3lWUK0D7cq2Lsf2jvrvm1hw3qF/6VXOuKsFfCj7sepKN0mVXHNtqvs65TzVfd+Fy5SnUL7p+0kEb+cK6TDvNJpUtmmzaMd/AuIBt0ZWjiR8fWal+qhM8yiar7b5EZTi+s12jbmMO7PqUcRvbgeM2225a/vA4Grtd64ohfqWZ59afAl7UvgIcBxD+NrDde0g29ovBUeSnE68IePzVYfZhqBOveOB6xkH7VQH/ioM28oV1mTbzafWU7Zps2mG7aG9su6qfEN5HVqqf6gSPsrEy31+M/hSV4Rjl+sVo03mln63W/137Cp4BvPyr7coXunSv1ZjFuqfGLGX/7DfQ/tlvoI6y38C+Zb/BvwTO8JwrMPhHKFeAOpJB12Wu4FXi8dPAg9JvnlsZ/Mvg2x5L8W09GXE+6ZkrsH5sR0yN9s6+wOWD4yer32S7xb7hnI7KO6BMOVdgMuoV8IivSvDPO3IF6I8+Tbz7/oI9xxloM5gr+C3KFaDtYq7gU6R76NPYX8QP657B/w7o86sUb4TwGy9SGfoBjq3VmKP0TK0V4RjK9cwPmF9BXWxHrsDw16LmNufJFSj7w/GBcwU5/eZEruA1QU/1A+YKUKZI33C5cgXt9GsoJx+/hvA8d8c2sj2jj2A/gD6C/ccLDnroIzAW/y2yfeUjfWMWnJ9/K4lZlI2z/aONs/2jvnPcgDLkuOFV4EXFPDhmI/wfgg/7NslG6bIrjn1dwL8GMC9Te1DXX/fA9UkH7c8I+NcdtJEvrMu002xS2aLJph3zDYwL2BZVPyG8j6xUP9UJHmWT1XZfpTIc39muUbdN55V+uuL8+GHbfVnwivHArpYr+D7YbnRyI07ln125gqzzdfRhr3rgcs3XXPqraCNfWJdpM59Wr5NyBaqfXD5WyUr1Uz1qtmu2wanMFbB+hsoVvPIGzxX4jPmYK0B4zhUY/EDSFxZ/oo4UzRW8RjxiPsNnXm/whyU8xn08M8W3+eYKDH7vBM/OzBWgvbMvcPng+MnqN9lusW92Vq7gIOgDV66A85qhcwVnJXy0yhUcTrqXN1ewDPT5qOS9nbkC9AOcK1BjjtIzlSvAMZTrmR8oOJf2zhUY/lrU3OY8uQJlf65cQU6/OZErUHMc1Q+YK1BzEcTVibmCVnLlubvKaWadb7D/yJMrOItsP1Su4LlAuQLUd44bUIYcN7wGvKiYB8dshL8AfNjbSTZKl11xbIj5uguXK1fwcwL+Mw7ayBfWZdppNjnVuQKMC9gWXTma+PGRleqnOsGjbLLa7mtUhuM72zXqNubA3p4ybmM78uQKOB5o9dtCHDepPVau+UmrvaM8P1GxkNpr9HQKHfQJ2Ccbk3fea3STZ0xttAvq+0C799G0mg/y2Rn03bznBWWM55F4bMAzLvfT2IC5KN6TofaHqnky617ab5TwfjKDv1PE7C59dp3/yqrP2Iai+oy2cQO11eBHp1afp+9sfWadRX3mnJDS50rU7MOK5HPe1YH6/9BupP9PdLj+q7mES/9b5UhY/zF+2xn6P5JB/1910FT6b21L03/MJyL8Sw79V/J16X+rNUKX/r9OZVjv6RQ6qP/Y76z/Bv+ap/4b7XboP8qI9d81b4qfrHMdXhPA+N2l/7xeG0r/z8ug/67YW+m/tTVN/w0f58t/zaH/ygbH4FvRtS5sw2tUhvWeTqGTFs+z/hv8lzz132i3Q/9Dzl9b5Rk4nkfbcOk/r3OE0v+TSP/HAI5zQ1nPsbvurrB2qDOb6jwAn9n8KuSG/p7myCpGct2RGGLO68I15qDd6m4Mpq3uxmBeIsGn1Wvj+a+edp9rVbJS/VQneJSNsq0xKvM9V/I8lY1DGZ4XY/0ci5rb4Wu7Y4D3r45rxPt8C7xZ73AdS96V/X+CyrCe604In3PsStfHiXdc74sEPK9FG/z/pbVo1JEMui7XovmuGjyHr/Sb1+4m1tRO2fFv3Mf/nuLbejLi/E/Pcdb6sR1rNiHvqmnlN9lu1dm0Cv2NuNT6DdtZb6Tnunwvi8HXkn5ttRbN93Go+5qUP+Izd+NQhmvRxyR88Bnd+B3Xomec0tjuvHcxzgd93it5D+k3xqlM3XXgGnOUntVFfRxDuZ75gYJnwL3Xog1/LWpuc561aGV/6pxuQb85sRat8oSqH3AtWp2hRVyuteh2+jXXPT6t5Mprw9hGtmf0Ea67d9h/+N7Vj7H4MWT7re7P4ZhlTLQjxvtHScyibNx1n5PPOXa1Zw7bh3qjfBiP2Qi/AHzYCpKN0mVXHNvqnPnz1B51ztyFy3W+3nVWVNFW53aYlyhKt0lliyabdsw3MC5gW2y1JusjK9VPdYJH2WS1XV7fVufYle1i/n1FyriN7cBxm233ecErxgMDgn7esZvvVEC7Rj64jeyDEC/H/KvBdq8j2YS+n2KM2qP277pwjTtot/IbY0S7vJ+iEV71Uz1q9oG8V0Td16Jsl3MM6u4UK1NjjtLPcdGOMfjmGnfHAe8TlCtQa5ku3Wt1D+RY8q7sn/eKYj32G2j/rrtZXXexsN/g+JDhOVdg8JuSvrD4E3Ukg67LXAGP43jmRuk3z60M/n7wbXek+LaejDjvgnmqK1cQaByvtnscb+U32W6xb3j+qMZSlCnnCkxGvZHOU/D9ywZ/r2eugOMF1zxA5e+UP8JcwcuUK0DbxVzBA6R7efNUnwZ93krxRgi/4Yqted+qGnOUnqm9gTiGcj3zA+ZXUBfbkSsw/LWouc15cgW+c/eCfnMiV6DicNUPmCtAmar7e1y5gnb6NVcOtJVcee6ObWR79s0nsv94zkEPfQTG4i97zDfGBF4Vs+B8YwvlClx3P6ONs/2r3K+a33LcoM7JqrOIfE7258GHfYlkE/pOLd6Hn/VOLVeOvdUZXaZd3qnVCK/6SZ05cd2p5bJdzjHg+M52jbqN+8u/lDJuYzvUWoiKB3DMf8CRK+DfvciaD1A2z3Gain3HBK8c+/4B2O632pznG6P2ZM3zjTtot8rzjRHtMs/XCK/6ySfPh797MU5lvvbJNo+63XAHTJtyBSspV6B8gkv3Wu2nGUves54hYb+RNR+gdJ39hvUn5goQnnMFBv9DyhXkvEdK5go+TTxiPkPpd9qZ4N4FO/6N+/hHKb6tJyPOf/HMFQTav535LKjLB8dPVr/JdqvG+Ar9jbjUGTC2s94ocp6d4DlzJelXlStAf8R5TfRHnAN5XtBV/ghzBYclfPBcJ37HXEHfgsZ2q7w++hzWPYM/AvR5z+Q9pN/gPU4qZ+Qac5SeqXVeHEO5nvmBgnNp71yB4a9FzW3OkytQ9qfmOwX95kSuoNU9cSpXoOYiiMuVK2inX3Oth7SSK8/d1Z0vyke41jDYfzzvoIc+AmPxw8j2lY8cE3hVzIL7Fc6hXAHaF9t/1nyAmltz3KDuk1V3E/F9sseBD1tCslG67IpjW83XXfd7+typVeTck+u+EKzLtNNsso33Tcj5Rsg7d5WsVD+pM2J8fsbXdvnOO5UPULaLObAlKeM2tkPlK1U8gGN+H43d4wDXybmC88F2ryHZlLmCZj7LXEFj2VTmClg/x0U7xuCbb66gv8wVZM4VrE/6opNzBR8A37YhxbdlzRXcDvPUMlfQiGuqcgXv6ZBcwZhnruCeQLmC50GfP1TmClxPmSsgemWuYOfkCsbalCvo2kVzBZ8CH/arZa6giXaaTZa5gmy2GyJX8KttyhXcQ2M3tmksaixT9w604wwC7tdIO4PwZbDdr5FsQp9BcO2N8jmD8KyDdqs8BdMuzyA0wqt+8jmDMAZlz1LZOJSFOIPA+vmsaIfv79s+C3i/fGwjXjWeu3Sv1RkE1xkk1xmEMSpT9w7srDMIf0u5gpwxfVvPIPwn+Lb/k+Lbsp5B+IFnrqA8g9As01BnEP7NkSsYg/qc5xiHshBnEOacuuO91RmE6NTGduc9g3DQqVAveQ/pN3iuUJ5B8KZXnkGIivu1qTqDMAZlrrPLIc4gzCHbVz7SN2bBMwi/msQsysbHosYyde/AzjqDcDj4sNNINuUZhHSbLM8gZLPdEGcQTksZt7Edec4gcDwwLvA+K/BWiF+ERx+S9T41zi363qc2lkIHfQL2yZ3JO9/DdHYij1YxtdEuqO+9St9dd+Wo+aArD9JqPmgyUbER360zBmVG03hW6/Sx7F+g+WwlKcM53jx4PxrKEf7apF8sbsB2ZpD3hf1QJwIciLuaE3eF8EWRjvMwplH04qcmyqoevBzz3juOPejOnuMrVN944W+sLz0C/nwBb7LqJd4HI6/nfGVTRtvKqlDGcSDahfEQ29Jzixv568nJn4/8EH9dwF88OgmXpS9mRo26gPpuvg/vvHmEytBnsj9VPtOVC2a/g/7U5w7aGyHG+lmPMWxn3kHruiPdlddUtNUck3mJovSxubyDtlG3sX/UWg3HbWNQ9jyVjUMZxgmsn76/I9Tq92PeQ2OgiplcutcqZmLd842Z2G+g/bv2lI5RmcrpsJ2hz/S5g/Z+Gu9z5kLaegftGPi2LYHyag9NbfxZ3kEbNd9B+zT0Aed00R/xnA/9kSvP43sH7a9RThdtF3O6z6XkdVD30Oek3UH766DPL1BON4TfGKey8g5ab3rlHbRRcb/mmle3kivnWNUap/IR7AfQR7D/GHPQG4d6GIv/Gtm+8pG+MQveQbuRcrpoX2z/aONs/1lzwTxuKB/GYzbC/zb4sL8i2ZR30KbbZHkHbTbb5bztGJS5csG4HvNXHusxOG6z7T4veFXxwKMCr7rvuhI1+yGfnO64gB8DGL57WuUKB0S9R1LopOUgOKdr8H/jGVOPJd/akdNFGbG+K5+N8CxvNX/EWJnn1yq/rvTdaBrPHxM4Y9lfTWPDUwD30aix7ONQxnuPUA/4PrIxKEM+0vRgq2gj68G/wtgwbWEjTtUHH4dvWftgK7UHfcDzHriectBulQ9g2iofwLxEgk+rp2zFZNOOsQF1v6itKFmpflLzCB43PgplT1GZ7/3HbH+o22PJu9LPp0Q7tsI3Hhu2Cl6356opF6X2Lbp0b0zAox2z7n1ctE/ZP/uNMShjv4E6yn4D+5b9BuaoIwHPuSiD3y/pC5vfoI5k0HWZi+J5L+YklH7z3N3gj0t4jPv4gBTf1pMR54EJnlbjpvVjO+ZsaO/sC1w+OH6y+k22W+ybjxOujwtcKFOOqUxGvZFejzZ8VYI/CvqAc1Hoj3gO6vvbbR+nMrQZzEVdkPCh1nsxF3U86d4YlLG/iB/WPYO/GPT5pOQ9pN/gmBT9AOJgnXLpmSvXp/TZ/ID5FdTFduSiDH8tam5znlyUsr8x+Ma5qJx+cyIXpfY+qH7AXJSaIyEuVy6qnX5tDAB8/BrCu/b7sT2jjxijMvQR7D+ecdBDHzFubYgmfYTLR/rGLB8HvP9yzI53ZeNs/2jjRX+blccN5cN4zEb4y8GH3UiyUbo8Dt+y7uPhvJvKh7twjTlot1p3d+X8ea2bc/HKJpUtmmzaMd8Iud9KyUr1k8ojc97I13Y5T4XjO9u1+m1WpZ9jUXM71D5AFQ+MAV6OBx4UeLsEXoPfCri6CUf8vjF5rxL8rSJ2NZwPCx5ce6IeEfAPA4zxMxA1+zHOlWO9+5J3pe8GV1Df5W95Y3tY31WuEOFZNtsEPObkODbaBmU8974PyoxmP+FBecc6MXNeIz8PCX6wb1m/HgZc3YQjft+cvFcJ/gMO/VL68gB8Yxm6ZI78KB3ivR9Yz+Sr9MvgCurXgNIvbA/rl0tf4odl85iARx2yvq0TPMrJytAujabag2nyjnXiC0c0wqH/qqT8a7zyN7YFxGV7BTkWCkEH221zOqOzBcpwHvck+W2USbeouyF5rxL8ZyEGeprmcVh/K9W3so+Dnf0/i9Prsw/GMYL3TqI80OektRPhN6e08xPA52ccuRLjq6Dd1ZXdoe/z8esIn9Wvs+9Gm9xCuLYIXGoewDFCb6T7wPBVCf51R64E2/cQ8X5fRt7VeKL8iNWNdekDiR8ZiJrHmIeJphrDVF/VRf2HUnB1Cf7RbrnfuyM9HjK86QTmK5V/rhL856GvfmOxxhml8LAlhefeFPhHiQeD/4LQF5cfQP1/hHAa/BcB5y9kxHlbCs7fcsQayk4xvs06nnI8gXJ8jMqQdx4XtwF9ht1E9LEM9ZzpRg5+eUxtxS+PN1b2dRiv/ojy/hhbZPDV3a6+ukTw69tXWxztY1xWD8/V+NgIyuMvFmqcPRlx/pUY01WscjTg/3pKPBJFzfFI/LBfRp+BdvgkxSRI/wHi38aJb3uuixiuYmN95ZtqrL8PIHisV7JBePYJaj6M/cgxNo43R1DZA1DGsdV9go7vWGp14z572xGNeLc68MbvP0N8tIrx1iXv7If/KWNOwSXzVjkFXkfF/uCcgtLZqdZHbD/ro6ut8ZN1Psz6qMYPpY8cZ7n0Jn5c+oh5qYsotkNejb7y0cxPq5i7SvDm43tT4NnnG/wepyX/Rs1xz+OCB9c84QkB/7jgeYB4wLpMG+0SZXLBaGN7DH46tMfljwPlPGYq/Ue5sf67ZBQ/LNMnBTzKymRSJ3iUr9L/x6lM5ZFcNutrG1Y37sfDyVeHzs+xrzb4NwudcLXN5avblZ9z+ep26mqn5udQV33zc/t6xAKu3KvSx62Cf5VX4n7HeqdGrfnaKviqi/qYx+V6lZR/jQ5/c+UGT6X2PORoT9YcBdZ/iNrzUMD2KJ5b5ToXnxY1tE35HJxb8Dhk8JefNlnvzOTdlevMqlNpuqtyO/FzyWg00f74CR8L6vXUqYwFOd7Dccwnl4e6h2PadpjRyfqB1uOkvNCeWV4u/xQ/PvMKlTtT+78fpDLEvZXohMqL/uDw1vw/6GhvK/3gHEkHrZ3t9LGZdSHr2hn7S6Sj/CX3MfpX7JcNyXuV4K9zxHRKD1x602quZfwo3dhGZSr/3kYf0tF68wiVqXygr964cng4Rtv4rfwdxpQ4TqI+I3zaugePwxX6Pg2+Y7311GaOkRj3zQRv7exNgTd8HIu8xzHHf7gFD7cQD4+04OFh4sHg3y94cMk/flwxYV/UbItZ95EiPuMHvyH+WqT1YzDyeiosP6On9CB+1Jlctie1huHygcrOfWKlIrhc+6EWEJ2s8yKsv9VBZ2FBOgsFnXbPvxYQnUcC0kGbWUh0Hg1IB/VgP6KzLSAdHI94T0tV8BCPE+M0z3sMylQMy2cTDP7vFk3W+wTN89BXII9YX+UysB1M75MJDfN/mF/N4I/k+SPD1Up2nybZqTUUl+wM/vdBdq85ZMe2rWKMgahZHhzTY96U10RVXha/sc6p3HW/qMfjFeZns8wVfWwD8dei5jbnGa9U/hljQj7X8dF89CbOdaizjaofZkRapupcJucdVbyhfOMTVIb+jPPnaN9HwzvSSGuTxbYDDv5UHIqxm8q3sO5Ndaz0cD56zlhJ5Yeyxkq8L6pTYyXkk2OlrDlXrP+Qg87CgnQWCjrtzu2WsZI/nTyx0rcCxUo3w3j/HRrv0Vf4xEoPi3Ywvb/vgFjpex7rCS7ZGfxKkN0/OGTHtl3GSpN84jfEX8ZK6bGSijfaGSs93KJNHCsp/lS8Ez+Dkd/jE0th+zL03cG+umn4Q8VSKi5RsZS1b1s+eoOxrk1L6mEcOwzval8S9leo/lO5mZ3Vf1vz0XP2n8pZhew/tK1heG/Vf8o2j4d3LMP2uOJKrD9VceXxRCdtjD9gUdTQNrWmhWM87xkw+Hkwxh+YvA8I2j77Atq4zt+d9byRa09xFGXfD2vrOGoc4vFLnfWpRM19ovYH8ZrTA4JO3Fd/nbJuXQG8G0Rdtm2Ef0TwYfB8xoVh+DyKwR+f6FTcf3el7INLO4+Stg57EuCc6vMoKGc+34H1XOuwBlfQJg5WNoHtYZtQe2tVrGjwvntr6wTPclL2FT+4Ls/6qXjdWoBX7kfsK94HjHcNqj0drJcGv0zopep/k3k7+t+1Dq9k6lqHbyVTzne59gi71uFD7fU9gMavds9ROWfwJPDSLXg1vFWCvwLG4JtoXLf5UhT52ayan+Gci/eT4tzsKQ9cLl/6tIB/ykEb+cK6TJv5tHpttC25Tw7n2mxbqp8Q3kdWqp/qBI+yyTpffpLKfOfLpvNKP1vdZeKyXcxLcc5K+SqX7oU4B6Lsn/2GGuOULbHfwL5lv8F5EIbnXKPBvyvpC5t/oY4UzTU+TTx+FHhQ+s05RIN/EHzbu1N8W09GnO/1HGetH9txfxraO/sClw+On6x+k+0W+8bnzC7KlON6k1GvgEd8fObpPugDvusA/dFHiXff/B2fI1JrCLHevJLwweeg4necLz9Euoc+jf1F/LDuGfzroM+PUrwRwm/w3k70AxynqjFH6ZmKz3AM5XrmB8yvoC62Iydu+GtRc5vz5K18c9QF/eZETvwZQU/1A+bEUaZI33C57oVsp19DOfn4NZUnr0fNbWR7Rh/BfgB9BPuPRx300EdgLP4K2b7ykb4xC65DfovWxNC+2P7Rxtn+Ud85bkAZctzwNPCiYh4csxH+F8GH/Q7JRumyK45Vv1GH9/89Tu1BXf+YB64nHLTV/Z4fc9BW9w4zL1GUbpPKFk027ZhvYFzAtqj6yfUbGUpWqp/qBI+yyWq7T1MZju9s16jbeF/876SM29gOHLfZdh8XvGI8MFV7/0LlCv4EbPdvOjxX4Mq3l7mChJ+otY8NmSvw3YcYIlfA+ul79r7VmetPe+QK2n1nhLJ/9hudlCv48S6QK5h2+o5/4z7+10C5gp+UuYKJsp2VK+hJ+lXlCtAftTtXcGTCR6tcQf/pje3OmyuYB/pcT95D+o0yV1DmCrYjT/59o+YK0Ee0O1dwJNl+qFzBuCNXwPbfSbmCE8GHLSPZlLmCdJsscwXZbDdErmBZyriN7ciTK+B4gPf0x89Vo5PfHow0H5UWfBi86UnaXqu03MCFEGfd5dgXZLjitl2c0jb0E2r+wzHezeAnLnHEOnyvhYp1oqjZL3N/Lh2NpAyuAj6uOD2dlulQv6ON2+/6PF3DIQ8IxzjsvgKUAY9vD4t6au7JZ3IeJxqPOWhsE/UUjUcJJ8pMnTX4aIvyJ0XbIvGtS8A/ntLeSNB+ogXexwQe5WtcPopjahUb4J0v7F/U3dCx7rwv2cup7CXNJpRePe7g/UnivdVeQOZdyQ/9h9ofyWcZWLceEe2siL+Nv+vgG/tYdQc7wlhd3p96p/CZjDNtH+DaFJw/Czh5f6rSmWPhG4/Frn5CftS+xsepnrpDKBLfVP9sIVjkIX7MFyqdfSSFDstD8eA6X+s6v9fqHi+XbeKewpvINjGe4TvnHyLeEXYr8cdnM1i/eT8s3sOj1gtYvw3+QYd+q3OByNfaFJwPO/Rbyf0Y+Jb1/jSeG6n70xTv6Hv4m+of1m8+B4T6zWd8tqbQUbrPPKh1J9PvB1NwMs2s81KrG/f7T+bueFfy5fvT1V4/tSevLurzHU3Gw3OgS/x7Fcinz5kWg3/BoZ+h70nntQLUqUcc9bD/+gStQXv5L/dj+MwW9ojSdZD3q78Kcvr8Ys1Lhflp8bTxHONghfBFkc4R7qLnGA8KcY6Rz0bF75jb/iWa7ykbw7prkne2sV+Fedb/TMEZRcV807fnNuJt192tynZ97s12/Q6N8aBiSIRfl7xzDPklsM3PtP1O+co/qpwSxog9o1FDu1znpuInaxzLv6Oj1kdc+qVyvaw3ab9TYPj4nNkfOtat8Fwen3V5MCPvaXcAsy2ibbAdPyjwuu61V3aPfNtvlrDd/6VjbA39uy+ue/w4j6TuGFb2YnDtuAO1U36DhONIdW+p8r0m71gnfpt8r7pvGfuW9QtxdQs+3pa8Vwn+/zj0q9W4kvVufb6b2fce9Pb/xk00a2efd7a+VbkkvqcbfSGfk1e/bRjrxEukX2qcxLpvT955nPxpxlyLy+ZajVHGjyvXonKqrEsqv2c8uPYaxO/XRo1ymMjHL56Uw2faf/Z0Sdb1YNdvysQP94VrjxzKpE7w3C/4N+Jyrb+o3zV6XODnu5/q0AeuMzGuHLMP78rvKntDm1rqmOdzzOr6fRqui2NPbwp82vxztpAX+7O03Os1hNPg5wBOnzvaPwLfst7RzrlXlY9U8wfX3QBh4vnorJ19RzuPH667/bPe0e6r/6hD80n/cTy/n2i64liui3TS9D/tjvTjHfrfal5+FeE0+JMc+q9k6dL/VjGCK0Zy3ctj/qaN8fmynR2fs/674vOseV5f/UcdOpDiLXV/Mta9Onnn+5OXZdQvnDfkjUGVDrl8L+dnVOzK/Zg2zvA8xeAv9Iy3Av3mxl4725/z2puKb13+03W3kPKfarxk//lWR7ylfstN2ZsP7772hja1J403OPfl8eZBB02ui3adNt4YPh4brnWMNzg3U/kgHm8Mfp3DHyjf5RpvWs3XOR+kflNZzeVd83WDK2ife7f7d7Va5cp4vEF/yL+Xg7bBsYxvnqfV/P5fD9vxXkyu79oOv52X0Unc3QLS8FcJ/s6kT2rAp/1b9eDjX8d/9PoLr/7p786k+vFjfTStAP4jP/jIZ5b/9X8sbRf+33vHRZ8fOefk6e3Cv+yl371t9pL/b5924f/SO37zqoEZUVe78B/7v/be98n/78LH2oX/V9fXTvjaS3vc0Ar/QPLeOzpZjn4qfvZI/rZzVQxv+KoE/1BiA7HtPEKxSo+gt32/ugOukvLvdhziW3W08VtttBm+e7QZ3mhPG23m0cr2hDL0sdthkr9RXoirBuUI//Gk7dYnfVDH6tcF/T6i38C3+IY+nnF1i28G///XZv0uBEVROD/yo169zOIfMZhlIBubUspCyvLewiKrKIsySFFG/gHFYmAwyULPZLIoE1059XXcEnXudm/nfN855zv3LEfp02NzDXP/dcetjo/54xvnpt6gXbU6/vpn7KgpxUe6YU25ptgfXojrxfm+o6aIhX8E7adMU8yN/E0NP9aFc+n4uaa6Xg9q7FVdR1DXf+dNdTnMGmerKDXPUla5ktmd9lL4l4TdT2/bHSn8gMuoPSKlmRS+E7ve7binIYWfczvheXQykMI/hm7J5sI8SOEX8q3xatNdf8N/Aic+bCrwuggA","debug_symbols":"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us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrPDuTztevnK1Jj0bTbFpNu8mavOk03ab2uO1x2+O2x22P2x63PW573Pa47XHbI9oj2iPaI9oj2iPaI9oj2iPaI8ojG5cejabZtJp2kzV502m6Te0x2mO0x2iP0R6jPUZ7jPYY7THaY7THbI/ZHrM9ZnvM9pjtMdtjtsdsj9keqz1We6z2WO2x2mO1x2qP1R6rPVZ77PbY7bHbY7fHbo/dHrs9dnvs9tjtYe1h7WHtYe1h7WHtYe1h7WHtYe3h7eHt4e3h7eHt4e3h7eHt4e3Rdb67znfX+e46313n2QJ1PMmavOk03aYoyjoHjabZ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bbptumWWLEuMxsySh4M4iYu4iUZ04iHSzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpdugXdgm5Bt6Bb0C3oFnQLugXdot3Q9/pwECdxETfRiE48xEuk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbphuz5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMkuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMEvS9rpN4iJcYjcgS4CBO4iJuohHptui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26Hbodul26Xbpdul26Xbpdul26ZJd9fupvoe30YjZkl+YfL0Pf6cBIXcRON6MRDvMR4uND3+nAQJ3ERN9GITjzES6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpdugXdgm5Bt6Bb0C3oFnQLugXdmCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZgr7X7y/5LvS9PhzEdLuJi7iJRnTiIV5iNCJLgINIt0M3ZMlMNKITD/ESoxFZAhzESVxEul26Xbpdul26XboF3YJuQbegW9At6BZ0C7oF3aLd0Pf6cBAncRE30YhOPMRLpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26RbZkn+XWT0vT6MxsyS93eOB3ES0y0SN9GITjzES4xGZAlwECeRbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpFnQLugXdgm5Bt6Bb0C3oFnSLdkPf68NBnMRF3EQjOvEQL5Fug26DboNug26DboNug26DboNug26TbpNuk26Tbrj3uhON6MRDvMRoxL1X4CBO4iLSbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3S7dLt0u3S7dLt0u3S7dLt0u3S7dgm5Bt6Bb0C3oFnQLugXdgm7Rbuh7fTiIk7iIm2hEJx7iJdJt0G3QbdBt0G3QLbPER6ITD/Fz85UYjZklDwdxEhdxE43oxEOk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oduh26Hboduh26Hboduh26Hbodul26Xbpdul26Xbpdul26Xbpdul26Bd2CbkG3oFvQLegWdAu6Bd2i3dD3+nAQJ3ERN9GITjzES6TboNug26DboNug26DboNugG7PEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCXoe/WTOIiTuIibaEQnHuIlRuOi26Lbotui26JbZsmxRCceYrrNxGhElgAHcRIXcRON6MRDpNumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oduh26Hboduh26Hboduh26Hbodul26Xbpdul26Xbpdul26Xbpdul26Bd2CbkG3oFvQLegWdAu6Bd2i3dD3+nAQJ3ERN9GITjzES6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbohuz5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrPkMksus+QySy6z5DJLLrMEfa83MbPk4SB+bnclLuImfm7fO9wX+l4fHuLndiMxGjNLHg7iJC7iJhrRiYdIt0O3S7dLt8ySsMRF3MQ/t7+nq4lOPMT7Ya7DlyUPvywpHB+exElcxE00ohMP8RKjMPteCwdxEhdxE43oxEO8RLoNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26Hbodul26Xbpdul26Xbpdul26XbpdulW9CNWRLMkmCWBLMkmCXBLAlmSTBLorNk/zpL9q+zZP86S/avs2T/Okv2r7Nk/zpL9q+zZP86S/bvR7dBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJ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","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"UsdoVault::check_and_trigger_emergency_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"UsdoVault::check_and_trigger_emergency_parameters","fields":[]}}]},{"kind":"struct","path":"UsdoVault::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"UsdoVault::constructor_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"zec_oracle","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"usdo_token","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"xusdo_token","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"zec_token","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"UsdoVault::deposit_and_mint_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"UsdoVault::deposit_and_mint_parameters","fields":[{"name":"zec_amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"UsdoVault::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"UsdoVault::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"PriceOracle::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"UsdoVault::redeem_usdo_for_zec_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"UsdoVault::redeem_usdo_for_zec_parameters","fields":[{"name":"usdo_amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"UsdoVault::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"UsdoVault::sync_private_state_parameters","fields":[]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"PriceOracle"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"zec_price","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"USDOToken"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"vault","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"XUsdoToken"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"vault","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"UsdoVault"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"floor_price_pf","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"alpha_high_buffer","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"beta_bonus","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"gamma_fee","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"delta_discount","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"kappa_emergency","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"phi_participation","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"lambda_decay","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}},{"name":"psi_floor_protection","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}},{"name":"zec_oracle","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000b"}}]}},{"name":"usdo_token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000c"}}]}},{"name":"xusdo_token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000d"}}]}},{"name":"zec_token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000e"}}]}},{"name":"emergency_mode","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000f"}}]}},{"name":"total_reserve_zec","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000010"}}]}},{"name":"total_usdo_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000011"}}]}},{"name":"total_xusdo_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000012"}}]}},{"name":"vap_balance_usd","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000013"}}]}},{"name":"last_mint_timestamp","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000014"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"60":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"69":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"71":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"73":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/event/event_selector.nr"},"75":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/hash.nr"},"92":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"96":{"source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"97":{"source":"use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"102":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"105":{"source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"107":{"source":"use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"108":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"110":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"111":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"112":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"113":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr"},"114":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"115":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr"},"116":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"117":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"133":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr"},"145":{"source":"use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"148":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"153":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"155":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"157":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"162":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"163":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"165":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr"},"170":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"173":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/oracle/version.nr"},"177":{"source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"187":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[public] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"203":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"206":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"207":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"209":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"210":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"212":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"214":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"226":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"245":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"291":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"307":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"316":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"330":{"source":"/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"331":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"332":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"342":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"344":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"357":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"359":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"360":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"377":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"380":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/serpepe/nargo/github.com/AztecProtocol/aztec-packages/v2.1.8/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"401":{"source":"use dep::aztec::macros::aztec;\n\nmod types;\n\n#[aztec]\ncontract UsdoVault {\n    use dep::aztec::macros::{functions::{initializer, public, private}, storage::storage};\n    use dep::aztec::{protocol_types::address::AztecAddress, state_vars::{Map, PublicMutable}};\n    use dep::aztec::protocol_types::abis::function_selector::FunctionSelector;\n    use dep::aztec::context::gas::GasOpts;\n    use dep::aztec::protocol_types::traits::ToField;\n    use crate::types::{get_precision, exp_decay, max, min};\n\n    #[storage]\n    struct Storage<Context> {\n        // Config\n        owner: PublicMutable<AztecAddress, Context>,\n        floor_price_pf: PublicMutable<u128, Context>,\n        alpha_high_buffer: PublicMutable<u128, Context>,\n        beta_bonus: PublicMutable<u128, Context>,\n        gamma_fee: PublicMutable<u128, Context>,\n        delta_discount: PublicMutable<u128, Context>,\n        kappa_emergency: PublicMutable<u128, Context>,\n        \n        phi_participation: PublicMutable<u128, Context>,\n        lambda_decay: PublicMutable<u128, Context>,\n        psi_floor_protection: PublicMutable<u128, Context>,\n        \n        // Addresses\n        zec_oracle: PublicMutable<AztecAddress, Context>,\n        usdo_token: PublicMutable<AztecAddress, Context>,\n        xusdo_token: PublicMutable<AztecAddress, Context>,\n        zec_token: PublicMutable<AztecAddress, Context>, // ZEC_WRAPPED\n        \n        emergency_mode: PublicMutable<bool, Context>,\n        \n        // Global Accounting\n        total_reserve_zec: PublicMutable<u128, Context>,\n        total_usdo_supply: PublicMutable<u128, Context>,\n        total_xusdo_supply: PublicMutable<u128, Context>,\n        vap_balance_usd: PublicMutable<u128, Context>,\n        \n        // User Positions (Simplified as public map for demo, ideally private notes)\n        // Mapping from (User + Index) hash to Position data is hard in simple storage.\n        // We'll use a simplified mapping for \"last mint timestamp\" to simulate age for now, \n        // or just accept that we can't fully implement the list of positions without custom notes.\n        // Let's implement the math assuming we have the timestamp.\n        // We'll store a \"mint_timestamp\" for the user's last action for simplicity in this iteration.\n        last_mint_timestamp: Map<AztecAddress, PublicMutable<u64, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(\n        owner: AztecAddress,\n        zec_oracle: AztecAddress,\n        usdo_token: AztecAddress,\n        xusdo_token: AztecAddress,\n        zec_token: AztecAddress\n    ) {\n        storage.owner.write(owner);\n        storage.zec_oracle.write(zec_oracle);\n        storage.usdo_token.write(usdo_token);\n        storage.xusdo_token.write(xusdo_token);\n        storage.zec_token.write(zec_token);\n        \n        // Set default params (scaled by PRECISION 1e9)\n        let p = get_precision();\n        storage.floor_price_pf.write(100 * p); // Example $100 floor\n        storage.alpha_high_buffer.write(500_000_000); // 0.5\n        storage.beta_bonus.write(10_000_000); // 0.01\n        storage.gamma_fee.write(100_000_000); // 0.1\n        storage.delta_discount.write(50_000_000); // 0.05\n        storage.kappa_emergency.write(800_000_000); // 0.8\n        \n        storage.phi_participation.write(700_000_000); // 0.7\n        storage.lambda_decay.write(20_000_000); // 0.02\n        storage.psi_floor_protection.write(1_100_000_000); // 1.1\n    }\n\n    #[public]\n    fn deposit_and_mint(zec_amount: u128) {\n        assert(storage.emergency_mode.read() == false, \"Emergency mode active\");\n        \n        let sender = context.msg_sender();\n        \n        // 1. Pull ZEC (Assuming public transfer for now)\n        // Token::at(storage.zec_token.read()).transfer_public(sender, context.this_address(), zec_amount).call(&mut context);\n        \n        // 2. Get Prices\n        let pf = storage.floor_price_pf.read();\n        let alpha = storage.alpha_high_buffer.read();\n        let oracle = storage.zec_oracle.read();\n        // Call public get_price\n        let selector = FunctionSelector::from_signature(\"get_price_public()\");\n        let args: [Field; 0] = [];\n        let ret = context.call_public_function(oracle, selector, args, GasOpts::default());\n        let pm = ret[0] as u128;\n        \n        let precision = get_precision();\n        let pt = pf * (precision + alpha) / precision;\n        \n        // 3. Determine Zone & Compute Mints\n        let mut usdo_minted: u128 = 0;\n        let mut xusdo_minted: u128 = 0;\n        \n        if pm >= pt {\n            // Zone 1: High Confidence\n            let beta = storage.beta_bonus.read();\n            let gamma = storage.gamma_fee.read();\n            \n            usdo_minted = zec_amount * pf * (precision + beta) / precision / precision;\n            \n            let excess_price = pm - pf;\n            xusdo_minted = zec_amount * excess_price * (precision - gamma) / precision / precision;\n            \n            // VAP Update\n            let extra = zec_amount * (pm - pt) / precision;\n            let current_vap = storage.vap_balance_usd.read();\n            storage.vap_balance_usd.write(current_vap + extra);\n            \n        } else if pm >= pf {\n            // Zone 2: Caution\n            let delta = storage.delta_discount.read();\n            let gamma = storage.gamma_fee.read();\n            \n            let numerator = pt - pm;\n            let denominator = pt - pf;\n            let discount_term = delta * numerator / denominator;\n            let multiplier = precision - discount_term;\n            \n            usdo_minted = zec_amount * pf * multiplier / precision / precision;\n            \n            let two_gamma = gamma * 2;\n            xusdo_minted = zec_amount * (pm - pf) * (precision - two_gamma) / precision / precision;\n            \n        } else {\n            // Zone 3: Emergency\n            let kappa = storage.kappa_emergency.read();\n            usdo_minted = zec_amount * pm * kappa / precision / precision;\n            xusdo_minted = 0;\n        }\n        \n        // 4. Update Reserves & Supply\n        let new_reserve = storage.total_reserve_zec.read() + zec_amount;\n        let new_usdo_supply = storage.total_usdo_supply.read() + usdo_minted;\n        let new_xusdo_supply = storage.total_xusdo_supply.read() + xusdo_minted;\n        \n        // Solvency check\n        let rhs = new_usdo_supply * precision;\n        let lhs = new_reserve * pf;\n        assert(lhs >= rhs, \"Solvency violated\");\n        \n        storage.total_reserve_zec.write(new_reserve);\n        storage.total_usdo_supply.write(new_usdo_supply);\n        storage.total_xusdo_supply.write(new_xusdo_supply);\n        \n        // 5. Mint Tokens (Public)\n        if usdo_minted > 0 {\n            let token_address = storage.usdo_token.read();\n            let mint_selector = FunctionSelector::from_signature(\"mint_public((Field),u128)\");\n            let args = [sender.to_field(), usdo_minted as Field];\n            context.call_public_function(token_address, mint_selector, args, GasOpts::default());\n        }\n        if xusdo_minted > 0 {\n            let token_address = storage.xusdo_token.read();\n            let mint_selector = FunctionSelector::from_signature(\"mint_public((Field),u128)\");\n            let args = [sender.to_field(), xusdo_minted as Field];\n            context.call_public_function(token_address, mint_selector, args, GasOpts::default());\n        }\n        \n        // Store timestamp for redemption\n        storage.last_mint_timestamp.at(sender).write(context.timestamp() as u64);\n    }\n\n    #[public]\n    fn redeem_usdo_for_zec(usdo_amount: u128) {\n        let sender = context.msg_sender();\n        \n        // 1. Get Prices\n        let pf = storage.floor_price_pf.read();\n        let oracle = storage.zec_oracle.read();\n        let selector = FunctionSelector::from_signature(\"get_price_public()\");\n        let args: [Field; 0] = [];\n        let ret = context.call_public_function(oracle, selector, args, GasOpts::default());\n        let pm = ret[0] as u128;\n        \n        assert(pm >= pf * 9 / 10, \"Price too low for normal redemption\");\n        \n        // 2. Calculate Redemption Value\n        // Using last_mint_timestamp as a simplified \"position age\"\n        let mint_timestamp = storage.last_mint_timestamp.at(sender).read();\n        let now = context.timestamp() as u64;\n        let t_days = (now - mint_timestamp) / 86400;\n        \n        let phi = storage.phi_participation.read();\n        let lambda = storage.lambda_decay.read();\n        let psi = storage.psi_floor_protection.read();\n        \n        let precision = get_precision();\n        let ratio = pm * precision / pf;\n        let excess_ratio = if ratio > precision { ratio - precision } else { 0 };\n        \n        let decay = exp_decay(lambda, t_days);\n        \n        let boost_term = phi * excess_ratio / precision * decay / precision;\n        let redeem_multiplier = precision + boost_term;\n        \n        let redeemable_usd = usdo_amount * redeem_multiplier / precision;\n        \n        let floor_protected = pf * psi / precision;\n        let denom_price = max(pm, floor_protected);\n        \n        let zec_out = redeemable_usd * precision / denom_price;\n        \n        // 3. Checks & Updates\n        let reserves = storage.total_reserve_zec.read();\n        assert(zec_out <= reserves, \"Insufficient reserves\");\n        \n        storage.total_reserve_zec.write(reserves - zec_out);\n        storage.total_usdo_supply.write(storage.total_usdo_supply.read() - usdo_amount);\n        \n        // 4. Burn USDO & Send ZEC\n        let token_address = storage.usdo_token.read();\n        let burn_selector = FunctionSelector::from_signature(\"burn_public((Field),u128)\");\n        let args = [sender.to_field(), usdo_amount as Field];\n        context.call_public_function(token_address, burn_selector, args, GasOpts::default());\n        // Token::at(storage.zec_token.read()).transfer_public(context.this_address(), sender, zec_out).call(&mut context);\n    }\n    \n    #[public]\n    fn check_and_trigger_emergency() {\n        let pf = storage.floor_price_pf.read();\n        let oracle = storage.zec_oracle.read();\n        let selector = FunctionSelector::from_signature(\"get_price_public()\");\n        let args: [Field; 0] = [];\n        let ret = context.call_public_function(oracle, selector, args, GasOpts::default());\n        let pm = ret[0] as u128;\n        \n        if pm < pf * 9 / 10 {\n            storage.emergency_mode.write(true);\n        }\n        \n        let s = storage.total_usdo_supply.read();\n        let r = storage.total_reserve_zec.read();\n        \n        let precision = get_precision();\n        if s * precision > r * pf * 15 / 10 {\n            storage.emergency_mode.write(true);\n        }\n    }\n}\n","path":"/Users/serpepe/Documents/Code/Onyx/contracts/usdo_vault/src/main.nr"},"402":{"source":"pub fn get_precision() -> u128 {\n    1_000_000_000\n}\n\n// Helper to calculate exp decay approximation\n// e^(-lambda * t)\n// lambda is scaled by PRECISION (per day)\n// t is in days\n// Returns scaled factor\npub fn exp_decay(lambda: u128, t_days: u64) -> u128 {\n    // Simple linear approximation for small lambda*t: 1 - lambda*t\n    // Or Taylor series: 1 - x + x^2/2 ...\n    // For this task, let's use a simple linear approx clamped to 0 if lambda*t > 1\n    // In production this would be a lookup table or better approx.\n    \n    let x = lambda * (t_days as u128);\n    let precision = get_precision();\n    if x >= precision {\n        0\n    } else {\n        precision - x\n    }\n}\n\npub fn max(a: u128, b: u128) -> u128 {\n    if a > b { a } else { b }\n}\n\npub fn min(a: u128, b: u128) -> u128 {\n    if a < b { a } else { b }\n}\n","path":"/Users/serpepe/Documents/Code/Onyx/contracts/usdo_vault/src/types.nr"}}}